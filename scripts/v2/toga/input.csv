focal_method,test_prefix,docstring
"static String leftPadding(String in, int count, char pad) {
        if (in.length() >= count)
            return in;

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < count - in.length(); i++) {
            sb.append(pad);
        }

        for (char c : in.toCharArray()) {
            sb.append(c);
        }

        return sb.toString();
    }","@Test(timeout = 4000)
  public void test3()  throws Throwable  {
      String string0 = Utilities.leftPadding(""cgD=LaK?RKcFsknRE."", 116, 'N');
      assertEquals(""cgD=LaK?RKcFsknRE."", string0);
  }","Applies a left padding to the provided string. If the string is already count in length, no change will be made. Otherwise, the pad character will be prepended until count length is satisfied.@param in String to left pad @param count Minimum string length to achieve @param pad Character to pad with @return String"
,"@Test(timeout = 4000)
  public void test0()  throws Throwable  {
      WorkUnitEvent.Type workUnitEvent_Type0 = WorkUnitEvent.Type.STATUS_CHANGED;
      DefaultWorkUnit defaultWorkUnit0 = new DefaultWorkUnit((-3079), (-3079));
      WorkUnitEvent workUnitEvent0 = null;
      try {
        workUnitEvent0 = new WorkUnitEvent((-3079), workUnitEvent_Type0, defaultWorkUnit0);
        fail(""Expecting exception: NoClassDefFoundError"");
      
      } catch(NoClassDefFoundError e) {
         //
         // com/google/common/base/Optional
         //
         verifyException(""me.marcosassuncao.servsim.job.WorkUnitEvent"", e);
      }
  }",
"public static StringBuffer readContent( File file, Map<String[], String> replaceMap )
        throws IOException
    {
        StringBuffer content = new StringBuffer();

        BufferedReader reader = new BufferedReader( new InputStreamReader( new FileInputStream( file ), ENCODING_UTF8 ) );

        String line = null;

        String currentEndString = null;

        try
        {
            while ( (line = reader.readLine()) != null )
            {
                if ( currentEndString != null )
                {
                    if ( line.contains( currentEndString ) )
                    {
                        currentEndString = null;
                    }

                    continue;
                }

                if ( replaceMap != null )
                {
                    for ( Entry<String[], String> entry : replaceMap.entrySet() )
                    {
                        if ( line.contains( entry.getKey()[0] ) )
                        {
                            currentEndString = (entry.getKey()[1] != null && !line.contains( entry.getKey()[1] )) ? entry.getKey()[1] : null;

                            line = entry.getValue();

                            break;
                        }
                    }
                }

                content.append( line + LINE_BREAK );
            }
        }
        finally
        {
            try
            {
                reader.close();
            }
            catch ( Exception ex )
            {
            }
        }

        return content;
    }","@Test(timeout = 4000)
  public void test07()  throws Throwable  {
      File file0 = MockFile.createTempFile(""X*?~5S^#Q`CK&"", ""zAO1FV"");
      HashMap<String[], String> hashMap0 = new HashMap<String[], String>();
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile(""/tmp/X*?~5S^#Q`CK&0zAO1FV"");
      FileSystemHandling.appendLineToFile(evoSuiteFile0, ""zAO1FV"");
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""X*?~5S^#Q`CK&"");
      StringBuffer stringBuffer0 = StreamUtils.readContent(file0, hashMap0);
      assertEquals("""", stringBuffer0.toString());
  }","Reads the content of the file to a StringBuffer. Each line is compared to the keys of the argument map. If a line is matched, the line is replaced with the keys corresponding value. Passing null as replace map argument skips value replacement. The reading will stop at the first match for a single line.@param file the file to read from. @param replaceMap a map containing keys to be matched and values with replacements. @return a StringBuffer with the content of the file replaced according to the Map. @throws IOException if operation failed."
"public static File getFile(URL resourceUrl) throws FileNotFoundException {
        return getFile(resourceUrl, ""URL"");
    }","@Test(timeout = 4000)
  public void test2()  throws Throwable  {
      URL uRL0 = MockURL.getFileExample();
      try { 
        ResourceUtil.getFile(uRL0);
        fail(""Expecting exception: FileNotFoundException"");
      
      } catch(FileNotFoundException e) {
         //
         // URL cannot be resolved to absolute file path because it does not reside in the file system: file://some/fake/but/wellformed/url
         //
         verifyException(""com.alipay.sofa.common.utils.ResourceUtil"", e);
      }
  }","Resolve the given resource URL to a {@code java.io.File}, i.e. to a file in the file system. @param resourceUrl the resource URL to resolve @return a corresponding File object @throws FileNotFoundException if the URL cannot be resolved to a file in the file system"
"public double distanceSquared(Vector3d v) {
        double dx = x - v.x;
        double dy = y - v.y;
        double dz = z - v.z;

        return dx * dx + dy * dy + dz * dz;
    }","@Test(timeout = 4000)
  public void test19()  throws Throwable  {
      Vector3d vector3d0 = new Vector3d(0.0, 0.0, 0.0);
      double double0 = vector3d0.distanceSquared(vector3d0);
      assertEquals(0.0, vector3d0.x, 0.01);
  }",Returns the squared of the Euclidean distance between this vector and vector v. @return squared distance between this vector and v
"public static OS getOS() {
        String osname = SystemUtil.OS_NAME;
        String osarch = SystemUtil.OS_ARCH;

        if (osname.indexOf(""Mac"") != -1) {
            if (osarch.equals(""x86"")) return OS.MAC;
            else if (osarch.equals(""x86_64"")) return OS.MAC_64;
        } else if (osname.indexOf(""Windows"") != -1) {
            if (osarch.equals(""x86"")) return OS.WIN;
            else if (osarch.equals(""x86_64"")||osarch.equals(""amd64"")) return OS.WIN_64;
        } else if (osname.indexOf(""Linux"") != -1) {
            if (osarch.equals(""i386"")) return OS.LINUX;
            else if (osarch.equals(""amd64"")) return OS.LINUX_64;
        }

        return OS.OTHER;
    }","@Test(timeout = 4000)
  public void test3()  throws Throwable  {
      SystemUtil systemUtil0 = new SystemUtil();
      assertEquals(OS.WIN_64, systemUtil0.getOS());
  }",Get information of OS environment. Detects OS name (e.g. Mac OS X) and architecture (e.g. x86_64).@return OSEnv enum object.
"public boolean addTimeSlot(long startTime, long finishTime, RangeList list) {		
		if(finishTime <= startTime) {
			return false;
		}
		Iterator<SingleProfileEntry> it = avail.itValuesFromPrec(startTime);
        SingleProfileEntry last = it.next();
        SingleProfileEntry newAnchor = null;

        if (last.getTime() < startTime) {
        	newAnchor = last.clone(startTime);
        	last = newAnchor;
        }

        SingleProfileEntry nextEntry = null;
        while(it.hasNext()) {
       		nextEntry = it.next();
       		if(nextEntry.getTime() > finishTime) {
       			break;
       		}
       			
       		// Remove duplicate entries. That is, entries whose PE ranges 
       		// are the same. This minimises the number of entries required
       		if(nextEntry.getTime() < finishTime && 
       				last.getAvailRanges().equals(nextEntry.getAvailRanges())) {
       			it.remove();
       		}
       		else {
	       		last.getAvailRanges().addAll(list.clone());
	       		last = nextEntry;
       		}
        }

        if (last.getTime() < finishTime) {
        	add(last.clone(finishTime));
        	last.getAvailRanges().addAll(list.clone());
        }
        
        if(newAnchor != null) {
        	add(newAnchor);
        }
        
        return true;
	}","@Test(timeout = 4000)
  public void test3()  throws Throwable  {
      SingleProfile singleProfile0 = new SingleProfile((-3019));
      LinkedTreeMap<Long, SingleProfileEntry> linkedTreeMap0 = singleProfile0.avail;
      Long long0 = new Long(536L);
      SingleProfileEntry singleProfileEntry0 = linkedTreeMap0.getPrecValue(long0, true);
      Long long1 = new Long((-1168L));
      linkedTreeMap0.put(long1, singleProfileEntry0);
      // Undeclared exception!
      try { 
        singleProfile0.addTimeSlot((-876L), (-197L), (RangeList) null);
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""me.marcosassuncao.servsim.profile.SingleProfile"", e);
      }
  }",Includes a time slot in this availability profile. This is useful if your scheduling strategy cancels a job and you want to update the availability profile. @param startTime the start time of the time slot. @param finishTime the finish time of the time slot. @param list the list of ranges of resources in the slot. @return <tt>true<tt> if the slot was included; <tt>false<tt> otherwise.
,"@Test(timeout = 4000)
  public void test6()  throws Throwable  {
      char[] charArray0 = new char[0];
      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
      LinkedList<CMARichMark> linkedList0 = new LinkedList<CMARichMark>();
      CMARichText cMARichText0 = new CMARichText(charBuffer0, linkedList0);
      CharSequence charSequence0 = cMARichText0.getValue();
      assertNull(charSequence0);
  }",
"public static double shortestDistance(
            final Triangle2D triangle, final Point2D point) {
        return shortestDistance(triangle.getVertex1(), triangle.getVertex2(),
                triangle.getVertex3(), point);
    }","@Test(timeout = 4000)
  public void test28()  throws Throwable  {
      InhomogeneousPoint2D inhomogeneousPoint2D0 = new InhomogeneousPoint2D();
      Triangle2D triangle2D0 = new Triangle2D(inhomogeneousPoint2D0, inhomogeneousPoint2D0, inhomogeneousPoint2D0);
      // Undeclared exception!
      try { 
        triangle2D0.getClosestPoint((Point2D) inhomogeneousPoint2D0);
        fail(""Expecting exception: NoClassDefFoundError"");
      
      } catch(NoClassDefFoundError e) {
         //
         // com/irurueta/geometry/Line2D
         //
         verifyException(""com.irurueta.geometry.Triangle2D"", e);
      }
  }","Computes the shortest distance from a given point to the boundaries of provided triangle, considering its boundaries as lines with a finite length. Distance is computed up to triangle boundary, no matter if point lies inside the triangle or not.@param triangle A triangle. @param point Point to be checked. @return Shortest distance to this triangle."
"public static String getFileContentAsString(File f) {

		if (f == null || !f.exists()) {
			return null;
		}
		StringWriter sw = new StringWriter();

		BufferedReader br = null;
		PrintWriter pw = null;
		try {
			FileInputStream fis = new FileInputStream(f);
			InputStreamReader ir = new InputStreamReader(fis, ""UTF-8"");
			br = new BufferedReader(ir);

			pw = new PrintWriter(sw);
			String s = null;
			while ((s = br.readLine()) != null) {
				pw.println(s);
			}
			pw.flush();
			// char[] buffer = new char[RouterServlet.BUFFER_SIZE];
			// int readLength = fr.read(buffer);
			// while (readLength != -1) {
			// w.write(buffer, 0, readLength);
			// readLength = fr.read(buffer);
			// }
		} catch (Exception e) {
			logger.error(e.getMessage());
			return null;
		} finally {

			try {
				br.close();
				pw.close();
			} catch (IOException e) {
				logger.error(e.getMessage());
			}

		}
		return sw.toString();
	}","@Test(timeout = 4000)
  public void test17()  throws Throwable  {
      MockFile mockFile0 = new MockFile(""%20"");
      // Undeclared exception!
      try { 
        FileUtil.getFileContentAsString(mockFile0);
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""com.britesnow.snow.util.FileUtil"", e);
      }
  }",Get the content of a file as a string. Return null if an exception occurs @return The content of the file as string. Null if the file is null or does not exist. Null if exception occurs.
"public static boolean isAtTopRightCorner(
            final double x, final double y, final double left,
            final double top, final double right, final double bottom,
            final double threshold) {
        // fix values in case that corners are reversed
        final double top2 = Math.max(top, bottom);
        final double right2 = Math.max(left, right);

        return x > (right2 - threshold) && y > (top2 - threshold);
    }","@Test(timeout = 4000)
  public void test122()  throws Throwable  {
      HomogeneousPoint2D homogeneousPoint2D0 = (HomogeneousPoint2D)Rectangle.getClosestPoint(1606.58503, 3974.6644, 3974.6644, (-407.374413558168), 1606.58503, 3974.6644);
      
      double double0 = Rectangle.getDistance((Point2D) homogeneousPoint2D0, 296.190947854435, 0.0, 446.67959, 583.50171237173);
      assertEquals(CoordinatesType.HOMOGENEOUS_COORDINATES, homogeneousPoint2D0.getType());
  }","Indicates if provided point coordinates are located at top-right corner of rectangle defined by provided top-left and bottom-right corners up to a certain threshold. A positive threshold moves top-right corner towards rectangle interior, a negative threshold moves top-right corner towards rectangle exterior.@param x x coordinate of point to be checked. @param y y coordinate of point to be checked. @param left left coordinate of rectangle. @param top top coordinate of rectangle. @param right right coordinate of rectangle. @param bottom bottom coordinate of rectangle. @param threshold threshold to use as a margin to determine whether point lies at top-right corner or not. @return true if point is at top-right corner, false otherwise.fix values in case that corners are reversed"
"public ProfileEntry checkPartAvailability(int partId, long time) {
		Map.Entry<Long, PartProfileEntry> entry = avail.getPrecEntry(time, true);
		if (entry != null) {
			return new Entry(time, entry.getValue().getAvailRanges(partId));
		}
		else {
			return new Entry(time);
		}
	}","@Test(timeout = 4000)
  public void test10()  throws Throwable  {
      ResourcePartition[] resourcePartitionArray0 = new ResourcePartition[0];
      PartProfile partProfile0 = new PartProfile(resourcePartitionArray0);
      // Undeclared exception!
      try { 
        partProfile0.checkPartAvailability((-1), (long) (-1));
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""me.marcosassuncao.servsim.profile.PartProfile"", e);
      }
  }",Returns a profile entry with the available resources at a given partition at a given time. It does not scan the profile to check if the resources will be available until the completion of a given job. It just returns an entry with the resources available at the given time. @param partId the partition from which the ranges will be obtained @param time the time from which availability is checked @return a {@link ProfileEntry} with the start time equals to the current time and the ranges available at the current time.
"public double getArea() {
        final Point3D origin = mVertices.get(0);
        final double inhomX0 = origin.getInhomX();
        final double inhomY0 = origin.getInhomY();
        final double inhomZ0 = origin.getInhomZ();

        final Iterator<Point3D> iterator = mVertices.iterator();

        // because there are at least 3
        // vertices
        Point3D prevPoint = iterator.next();
        Point3D curPoint;
        double avgX = 0.0;
        double avgY = 0.0;
        double avgZ = 0.0;
        while (iterator.hasNext()) {
            curPoint = iterator.next();

            final double inhomX1 = prevPoint.getInhomX();
            final double inhomY1 = prevPoint.getInhomY();
            final double inhomZ1 = prevPoint.getInhomZ();

            final double inhomX2 = curPoint.getInhomX();
            final double inhomY2 = curPoint.getInhomY();
            final double inhomZ2 = curPoint.getInhomZ();

            // compute cross product of ab = (prevPoint - origin) and
            // ac = (curPoint - origin)
            final double abX = inhomX1 - inhomX0;
            final double abY = inhomY1 - inhomY0;
            final double abZ = inhomZ1 - inhomZ0;

            final double acX = inhomX2 - inhomX0;
            final double acY = inhomY2 - inhomY0;
            final double acZ = inhomZ2 - inhomZ0;

            final double crossX = abY * acZ - abZ * acY;
            final double crossY = abZ * acX - abX * acZ;
            final double crossZ = abX * acY - abY * acX;

            avgX += crossX;
            avgY += crossY;
            avgZ += crossZ;

            prevPoint = curPoint;
        }

        return 0.5 * Math.sqrt(avgX * avgX + avgY * avgY + avgZ * avgZ);
    }","@Test(timeout = 4000)
  public void test13()  throws Throwable  {
      HomogeneousPoint3D homogeneousPoint3D0 = new HomogeneousPoint3D();
      Triangle3D triangle3D0 = new Triangle3D(homogeneousPoint3D0, homogeneousPoint3D0, homogeneousPoint3D0);
      List<Point3D> list0 = triangle3D0.getVertices();
      Polygon3D polygon3D0 = new Polygon3D(list0);
      double double0 = polygon3D0.getArea();
      assertEquals(Double.NaN, double0, 0.01);
  }","Returns signed area of this polygon. The sign of the area determines whether vertices of the polygon are provided in clockwise (negative sign) or clockwise (positive sign) order.@return Signed area of this polygon.because there are at least 3
vertices"
"public void nNearest(final int jpt, final int[] nn, final double[] dn, final int n) {
        if (n < 0) {
            throw new IllegalArgumentException(""no neighbours requested"");
        }
        if (n > mNpts - 1) {
            throw new IllegalArgumentException(""too many neighbours requested"");
        }
        if (nn.length != n || dn.length != n) {
            throw new IllegalArgumentException(""invalid result array lengths"");
        }

        int i;
        int k;
        int ntask;
        int kp;
        final int[] task = new int[N_TASKS];
        double d;
        for (i = 0; i < n; i++) {
            dn[i] = BIG;
        }
        kp = mBoxes[locate(jpt)].mMom;
        while (mBoxes[kp].mPtHi - mBoxes[kp].mPtLo < n) {
            kp = mBoxes[kp].mMom;
        }
        for (i = mBoxes[kp].mPtLo; i <= mBoxes[kp].mPtHi; i++) {
            if (jpt == mPtIndx[i]) {
                continue;
            }
            d = distance(mPtIndx[i], jpt);
            if (d < dn[0]) {
                dn[0] = d;
                nn[0] = mPtIndx[i];
                if (n > 1) {
                    siftDown(dn, nn, n);
                }
            }
        }
        task[1] = 0;
        ntask = 1;
        while (ntask != 0) {
            k = task[ntask--];
            if (k == kp) {
                continue;
            }
            if (mBoxes[k].getDistance(mPts[jpt]) < dn[0]) {
                if (mBoxes[k].mDau1 != 0) {
                    task[++ntask] = mBoxes[k].mDau1;
                    task[++ntask] = mBoxes[k].mDau2;
                } else {
                    for (i = mBoxes[k].mPtLo; i <= mBoxes[k].mPtHi; i++) {
                        d = distance(mPtIndx[i], jpt);
                        if (d < dn[0]) {
                            dn[0] = d;
                            nn[0] = mPtIndx[i];
                            if (n > 1) {
                                siftDown(dn, nn, n);
                            }
                        }
                    }
                }
            }
        }
    }","@Test(timeout = 4000)
  public void test36()  throws Throwable  {
      LinkedList<Point2D> linkedList0 = new LinkedList<Point2D>();
      InhomogeneousPoint2D inhomogeneousPoint2D0 = new InhomogeneousPoint2D();
      linkedList0.add((Point2D) inhomogeneousPoint2D0);
      linkedList0.add((Point2D) inhomogeneousPoint2D0);
      linkedList0.addLast(inhomogeneousPoint2D0);
      double[] doubleArray0 = new double[2];
      Point2D[] point2DArray0 = new Point2D[2];
      KDTree2D kDTree2D0 = new KDTree2D(linkedList0);
      kDTree2D0.nNearest((Point2D) inhomogeneousPoint2D0, point2DArray0, doubleArray0, 2);
      assertArrayEquals(new double[] {1.7976931348623157E308, 1.7976931348623157E308}, doubleArray0, 0.01);
  }",Gets n nearest point indices to a given one in the input collection.@param jpt index of point to search nearest ones for. @param nn array containing resulting indices of nearest points up to the number of found points. @param dn array containing resulting distances to nearest points up to the number of found points. @param n number of nearest points to find. @throws IllegalArgumentException if number of nearest points is invalid or if length of arrays containing results are not valid either.
"public void add(E object) {
        while (objectCache.size() >= maxMemSize) {
            logger.warn(String.format(""Store is full (%d). Waiting to add object."", maxMemSize));
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                logger.error(""Error while waiting to add object!"", e);
            }
        }
        synchronized (objectCache) {
            objectCache.add(object);
            if (logger.isDebugEnabled()) {
                logger.debug(String.format(""Object added. Store fill status: %d/%d"", objectCache.size(), maxMemSize));
            }
        }
    }","@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      ObjectStore<Object> objectStore0 = null;
      try {
        objectStore0 = new ObjectStore<Object>((-2004L));
        fail(""Expecting exception: NoClassDefFoundError"");
      
      } catch(NoClassDefFoundError e) {
         //
         // org/apache/logging/log4j/LogManager
         //
         verifyException(""net.dschinghiskahn.objectstore.ObjectStore"", e);
      }
  }",Adds the object to the store. @param object The object to add to the store.
"public String toHexString() {
        if (mValue == null) {
            return null;
        }

        final int l = mValue.length;
        final char[] out = new char[l * 2 + 2];
        out[0] = '0';
        out[1] = 'x';
        for (int i = 0, j = 2; i < l; i++) {
            out[j++] = HEX_DIGITS[(0xF0 & mValue[i]) >>> 4];
            out[j++] = HEX_DIGITS[0x0F & mValue[i]];
        }
        return new String(out);
    }","@Test(timeout = 4000)
  public void test36()  throws Throwable  {
      BeaconIdentifier beaconIdentifier0 = BeaconIdentifier.parse(""00000000000000000000000000000000"", 12);
      // Undeclared exception!
      try { 
        beaconIdentifier0.toString();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 2
         //
         verifyException(""com.irurueta.navigation.indoor.BeaconIdentifier"", e);
      }
  }",Represents the value as a hexadecimal String. The String is prefixed with <code>0x<code>. For example 0x0034ab.@return value as hexadecimal String.
"public static synchronized ProcessEnvironment getInstance() {
		if (env == null) {
			env = new ProcessEnvironment(System.getenv());
		}
		return env;
	}","@Test(timeout = 4000)
  public void test0()  throws Throwable  {
      ProcessEnvironment processEnvironment0 = ProcessEnvironment.getInstance();
      assertNull(processEnvironment0);
  }",Get main instance @return Instance
"private static boolean checkDate(Calendar cal, Calendar other) {
		return checkDate(cal, other.get(Calendar.DATE), other.get(Calendar.MONTH));
	}","@Test(timeout = 4000)
  public void test0()  throws Throwable  {
      MockDate mockDate0 = new MockDate();
      Date date0 = NorwegianDateUtil.addWorkingDaysToDate(mockDate0, 1);
      assertEquals(""Thu May 01 20:21:21 GMT 2014"", date0.toString());
  }","Check if the given dates match on day and month.@param cal The Calendar representing the first date. @param other The Calendar representing the second date. @return true if they match, false otherwise."
"public static String getSignatureFromInternalName(final String internalName) {
		final int arrayDimension = countOccurrences(internalName, ""["");
		String finalTypeName = internalName.replace(""["", """");
		if (!isPrimitiveSignature(finalTypeName)) {
			finalTypeName = ""L"" + finalTypeName.replace(""."", ""/"") + "";"";
		}
		String prefix = """";
		for (int i = 0; i < arrayDimension; ++i) {
			prefix += ""["";
		}
		return prefix + finalTypeName;
	}","@Test(timeout = 4000)
  public void test32()  throws Throwable  {
      String string0 = Reflector.getSignatureFromInternalName(""O"");
      assertEquals(""O"", string0);
  }",Get the signature from of the fully qualified type name (internal name) provided @param internalName Internal Name of the type @return The signature from of the fully qualified type name (internal name) provided
"public void closestPoint(final Point2D point, final Point2D result) {
        // iterate over all vertices and compute their distance
        Iterator<Point2D> iterator = mVertices.iterator();
        Point2D prevPoint = iterator.next();
        // to increase accuracy
        prevPoint.normalize();

        Point2D curPoint;
        double bestDist = Double.MAX_VALUE;
        double dist;
        boolean found = false;
        final Line2D line = new Line2D();
        final Point2D pointInLine = Point2D.create();

        while (iterator.hasNext()) {
            curPoint = iterator.next();
            // to increase accuracy
            curPoint.normalize();

            // check if point lies in the segment of the boundary of this polygon
            if (point.isBetween(curPoint, prevPoint)) {
                result.setCoordinates(point);
                return;
            }

            line.setParametersFromPairOfPoints(curPoint, prevPoint);
            // to increase accuracy
            line.normalize();

            // find closest point to line
            line.closestPoint(point, pointInLine);
            // to increase accuracy
            pointInLine.normalize();

            if (pointInLine.isBetween(curPoint, prevPoint)) {
                // closest point lies within segment of polygon boundary, so we
                // keep distance and point
                dist = point.distanceTo(pointInLine);
                if (dist < bestDist) {
                    // a better point has been found
                    bestDist = dist;
                    result.setCoordinates(pointInLine);
                    found = true;
                }
            }

            prevPoint = curPoint;
        }

        // try last vertex with first
        // check if point lies in the segment of the boundary of this polygon
        final Point2D first = mVertices.get(0);
        if (point.isBetween(prevPoint, first)) {
            result.setCoordinates(point);
            return;
        }

        line.setParametersFromPairOfPoints(prevPoint, first);
        // to increase accuracy
        line.normalize();

        // find closest point to line
        line.closestPoint(point, pointInLine);
        // to increase accuracy
        pointInLine.normalize();

        if (pointInLine.isBetween(prevPoint, first)) {
            // closest point lies within segment of polygon boundary, so we
            // keep distance
            dist = point.distanceTo(pointInLine);
            if (dist < bestDist) {
                // a better point has been found
                bestDist = dist;
                result.setCoordinates(pointInLine);
                found = true;
            }
        }


        if (!found) {
            // no closest point was found on a segment belonging to polygon
            // boundary so we search for the closest vertex
            iterator = mVertices.iterator();
            while (iterator.hasNext()) {
                curPoint = iterator.next();
                dist = point.distanceTo(curPoint);
                if (dist < bestDist) {
                    // a better vertex has been found
                    bestDist = dist;
                    result.setCoordinates(curPoint);
                }
            }
        }
    }","@Test(timeout = 4000)
  public void test14()  throws Throwable  {
      HomogeneousPoint2D homogeneousPoint2D0 = new HomogeneousPoint2D();
      Triangle2D triangle2D0 = new Triangle2D(homogeneousPoint2D0, homogeneousPoint2D0, homogeneousPoint2D0);
      List<Point2D> list0 = triangle2D0.getVertices();
      Polygon2D polygon2D0 = new Polygon2D(list0);
      // Undeclared exception!
      try { 
        polygon2D0.getClosestPoint(homogeneousPoint2D0);
        fail(""Expecting exception: NoClassDefFoundError"");
      
      } catch(NoClassDefFoundError e) {
         //
         // com/irurueta/geometry/Line2D
         //
         verifyException(""com.irurueta.geometry.Polygon2D"", e);
      }
  }","Computes the closes point to provided point that is locus of this polygon (i.e. lies on a border of this polygon).@param point Point to be checked. @param result Instance where the closest point will be stored.iterate over all vertices and compute their distance
to increase accuracy
try last vertex with first
check if point lies in the segment of the boundary of this polygon
to increase accuracy
find closest point to line
to increase accuracy"
"public static String getQuotedCommaDelimitedString( Collection<String> elements )
    {
        if ( elements != null && elements.size() > 0 )
        {
            final StringBuffer buffer = new StringBuffer();        
        
            for ( String element : elements )
            {
                buffer.append( ""'"" ).append( element.toString() ).append( ""', "" );
            }
            
            return buffer.substring( 0, buffer.length() - "", "".length() );
        }
        
        return null;
    }","@Test(timeout = 4000)
  public void test37()  throws Throwable  {
      String[] stringArray0 = new String[3];
      LinkedList<Object> linkedList0 = new LinkedList<Object>();
      // Undeclared exception!
      try { 
        TextUtils.join((List<Object>) linkedList0, ""null&*xCXe[@*z[rY82Hv&*xCXe[@*z[rY82Hv&*xCXe[@*z[rY82HvZ6`r&*xCXe[@*z[rY82H"", (Object) stringArray0[0]);
        fail(""Expecting exception: NoClassDefFoundError"");
      
      } catch(NoClassDefFoundError e) {
         //
         // org/apache/commons/lang3/StringUtils
         //
         verifyException(""org.hisp.dhis.commons.util.TextUtils"", e);
      }
  }","Transforms a collection of strings into a comma delimited string, where each component get single-quoted. @param elements the collection of Integers @return a comma delimited String."
"public static synchronized void registerUtility(Object utility, Class iface){
        IOC.registerUtility(utility, iface, ""."");

    }","@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      Class<Object> class0 = Object.class;
      // Undeclared exception!
      try { 
        IOC.registerUtility((Object) class0, (Class) class0);
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""com.axiastudio.zoefx.core.IOC"", e);
      }
  }",Registers the unnamed utility for the given interface.@param utility The utility object to register @param iface The interface implemented by the utility
"public CMAWebhookTransformation setContentType(String contentType) {
    this.contentType = contentType;
    return this;
  }","@Test(timeout = 4000)
  public void test3()  throws Throwable  {
      CMAWebhookTransformation cMAWebhookTransformation0 = new CMAWebhookTransformation();
      CMAWebhookTransformation cMAWebhookTransformation1 = cMAWebhookTransformation0.setContentType(""QCA3dVCx"");
      assertNull(cMAWebhookTransformation1.getContentType());
  }",Sets a content type to this webhook transformation.@param contentType the contentType to set @return this webhook for chaining
,"@Test(timeout = 4000)
  public void test04()  throws Throwable  {
      StrokeChooserDialog.DashInfo strokeChooserDialog_DashInfo0 = new StrokeChooserDialog.DashInfo((float[]) null, 0.0F);
      // Undeclared exception!
      try { 
        strokeChooserDialog_DashInfo0.equals((Object) null);
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""de.chrlembeck.util.swing.components.StrokeChooserDialog$DashInfo"", e);
      }
  }",
"@Override public String getNodeType() {
    if (data instanceof CMALink) {
      final CMAType linkType = ((CMALink) data).getSystem().getLinkType();
      final String block = inline ? ""inline"" : ""block"";

      if (linkType == CMAType.Asset) {
        return ""embedded-asset-"" + block;
      } else if (linkType == CMAType.Entry) {
        return ""embedded-entry-"" + block;
      }
    }
    return super.getNodeType();
  }","@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      CMAType cMAType0 = CMAType.Asset;
      CMALink cMALink0 = new CMALink(cMAType0);
      CMARichEmbeddedLink cMARichEmbeddedLink0 = new CMARichEmbeddedLink(cMALink0, false);
      String string0 = cMARichEmbeddedLink0.getNodeType();
      assertEquals(""embedded-asset-inline"", string0);
  }",@return the internal representation of this node type.
"public static EventObjsMeetConditionID newEventObjsMeetConditionID(final String uuidStr) {
		ID id = dataClayIDs.get(uuidStr);
		if (id == null) {
			// For more information about locking design, see Pool
			synchronized (dataClayIDs) { // ensure only one is created per object
				id = dataClayIDs.get(uuidStr);
				if (id == null) {
					id = new EventObjsMeetConditionID(uuidStr);
					dataClayIDs.put(uuidStr, id);
				}
			}
		}
		return (EventObjsMeetConditionID) id;
	}","@Test(timeout = 4000)
  public void test11()  throws Throwable  {
      // Undeclared exception!
      try { 
        DataClayIDFactory.newEventObjsMeetConditionID("" the hint : "");
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.util.concurrent.ConcurrentHashMap"", e);
      }
  }",Create a new EventObjsMeetConditionID. @param uuidStr UUID string representation. @return EventObjsMeetConditionID.
"public long getNumberUsedUnits(long startTime, long endTime) {
		Collection<ProfileEntry> avail = profile.getAvailability(startTime, endTime);
		long units = 0;
		Iterator<ProfileEntry> it = avail.iterator();
		ProfileEntry prev = it.next();
		
		while (it.hasNext()) {
			ProfileEntry curr = it.next();
			
			if (curr.getTime() < startTime) {
				prev = curr;
				continue;
			}
			
			if (curr.getTime() > endTime) {
				break;
			}
			
			long time = curr.getTime() - Math.max(startTime, prev.getTime());
			units += time * (super.getCapacity() - prev.getNumResources());
			prev = curr;
		}
		
		long time = endTime - Math.max(startTime, prev.getTime());
		units += time * (super.getCapacity() - prev.getNumResources());
		return units;
	}","@Test(timeout = 4000)
  public void test0()  throws Throwable  {
      DefaultResourcePool defaultResourcePool0 = null;
      try {
        defaultResourcePool0 = new DefaultResourcePool(9);
        fail(""Expecting exception: NoClassDefFoundError"");
      
      } catch(NoClassDefFoundError e) {
         //
         // com/google/common/base/Preconditions
         //
         verifyException(""me.marcosassuncao.servsim.SimEntity"", e);
      }
  }",Returns the number of simulation units over which resources have been used. This is useful for computing resource utilisation. @param startTime start time to consider when computing the units @param endTime end time to consider when computing the units @return the number of used resource units
"public static <L, R> Pair<L, R> of(L left, R right) {
        Pair<L, R> pair = new Pair<L, R>();
        pair.left = left;
        pair.right = right;
        return pair;
    }","@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      Integer integer0 = new Integer(2219);
      Pair<Integer, Integer> pair0 = Pair.of(integer0, integer0);
      Integer integer1 = pair0.getLeft();
      assertNull(integer1);
  }",Creates a new pair of these values.@param left The left side of the pair. @param right The right side of the pair. @return The pair.
"public static String generatePythonMethod(final String methodName, final String[] parameters, final int level) {
		final StringBuffer result = new StringBuffer();
		// prepare indentation
		result.append(generateIndent(level));
		// prepare method
		result.append(""def "" + methodName + ""(self"");
		if (parameters != null) {
			for (String p : parameters) {
				result.append("", "" + p);
			}
		}
		result.append(""):\n"");
		return result.toString();
	}","@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      String string0 = LineFactory.generatePythonMethod("""", (String[]) null, 1467);
      assertEquals(""def (self):\n"", string0);
  }","Generates a method definition for a class in Python @param methodName Name of the method @param parameters Array of parameter names @param level Indentation level to use. @return An string defining the method using Python syntax ""[_indent_level]def methodName(self, parameters[0], parameters[1]...):\n""prepare indentation
prepare method"
"public boolean setTime(long time) {
		if(time < 0) {
			return false;
		}
		
		this.time = time;
		return true;
	}","@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      SingleProfileEntry singleProfileEntry0 = new SingleProfileEntry((-19L));
      boolean boolean0 = singleProfileEntry0.setTime(1176L);
      assertTrue(boolean0);
  }",Sets the time associated with this entry @param time the time associated with this entry @return {@code true} if the time has been set successfully or {@code false} otherwise.
"public CMAUiExtensionParameter setType(CMAUiExtensionParameterType type) {
    this.type = type;
    return this;
  }","@Test(timeout = 4000)
  public void test5()  throws Throwable  {
      CMAUiExtensionParameter cMAUiExtensionParameter0 = new CMAUiExtensionParameter();
      CMAUiExtensionParameterType cMAUiExtensionParameterType0 = CMAUiExtensionParameterType.Number;
      CMAUiExtensionParameter cMAUiExtensionParameter1 = cMAUiExtensionParameter0.setType(cMAUiExtensionParameterType0);
      assertNull(cMAUiExtensionParameter1.getType());
  }",Sets the type for this parameter.@param type the type to be set. @return this {@code CMAUiExtensionParameter} instance.
,"@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      EventTypeOuter.EventTypeEnum eventTypeOuter_EventTypeEnum0 = EventTypeOuter.EventTypeEnum.getFromID((-915));
      assertEquals(EventTypeOuter.EventTypeEnum.PERSISTED_OBJ, eventTypeOuter_EventTypeEnum0);
  }",
"public static String toHexString(final byte[] bytes) {
        final StringBuilder builder = new StringBuilder();
        for (final byte b : bytes) {
            final int high = (b & 0xf0) >> 4;
            final int low = b & 0xf;
            builder.append(HEX[high]);
            builder.append(HEX[low]);
        }
        return builder.toString();
    }","@Test(timeout = 4000)
  public void test10()  throws Throwable  {
      byte[] byteArray0 = new byte[1];
      String string0 = StringUtils.toHexString(byteArray0);
      assertEquals(""0F"", string0);
  }","Wandelt das übergebene Byte-Array in eine Zeichenkette, in der die Bytes in hexadezimaler Schreibweise enthalten sind, um. Jedes Byte wird dabei durch genau zwei Zeichen im Bereich von (00..FF) dargestellt. Beispiel: [255,20] --&gt; &quot;FF14&quot; @param bytes Bytes, die textuell dargestellt werden sollen. @return Die Bytes als hexadezimale Darstellung."
,"@Test(timeout = 4000)
  public void test03()  throws Throwable  {
      Range range0 = new Range(173, 173);
      RangeList rangeList0 = new RangeList(range0);
      TimeSlot timeSlot0 = new TimeSlot(1L, 0L, rangeList0);
      boolean boolean0 = timeSlot0.setResourceRanges(rangeList0);
      assertTrue(boolean0);
  }",
"public static byte[] readJar(final String path) {
		byte[] result = null;
		try {
			final FileInputStream fis = new FileInputStream(path);
			// System.out.println(file.exists() + ""!!"");
			// InputStream in = resource.openStream();
			final ByteArrayOutputStream bos = new ByteArrayOutputStream();
			final byte[] buf = new byte[MAX_BYTES];
			int totalbytes = 0;
			int readNum = fis.read(buf);
			while (readNum != -1) {
				bos.write(buf, 0, readNum); // no doubt here is 0
				// Writes len bytes from the specified byte array starting at offset off to this byte array output stream.
				totalbytes += readNum;
				readNum = fis.read(buf);
			}
			System.out.println(""[DATACLAY] Library serialized: "" + totalbytes + "" bytes"");
			result = bos.toByteArray();
			fis.close();
		} catch (Exception e) {
			e.printStackTrace();
			throw new DataClayRuntimeException(ERRORCODE.ERROR_DEPLOYING_LIB, ""Error while reading Jar"", true);
		}
		return result;
	}","@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile(""NO_OTHER_IMPL_FOR_OPERATION"");
      FileSystemHandling.appendLineToFile(evoSuiteFile0, ""[,!SbE9_37T 2fIW"");
      byte[] byteArray0 = JarUtils.readJar(""NO_OTHER_IMPL_FOR_OPERATION"");
      assertEquals(0, byteArray0.length);
  }",Read Jar file into byte array @param path Path of the Jar file @return Byte array representation of the Jar file
"public CMAEntry setField(String key, String locale, Object value) {
    if (fields == null) {
      fields = new LinkedHashMap<String, LinkedHashMap<String, Object>>();
    }

    LinkedHashMap<String, Object> field = fields.get(key);
    if (field == null) {
      field = new LinkedHashMap<String, Object>();
    }

    field.put(locale, value);
    fields.put(key, field);
    return this;
  }","@Test(timeout = 4000)
  public void test02()  throws Throwable  {
      CMAEntry cMAEntry0 = new CMAEntry();
      CMAEntry.Localized cMAEntry_Localized0 = cMAEntry0.localize("""");
      // Undeclared exception!
      try { 
        cMAEntry_Localized0.setField("""", """");
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""com.contentful.java.cma.model.CMAEntry"", e);
      }
  }",Creates a new field with the given {@code value}. If a field named {@code key} already exists it will be replaced.@param key field key @param locale locale @param value value @return this {@code CMAEntry}
"public static <T extends Collection<V>, V> T inverseFilter( T collection, Filter<V> filter )
    {
        if ( collection == null || filter == null )
        {
            return null;
        }
        
        final Iterator<V> iterator = collection.iterator();
        
        while ( iterator.hasNext() )
        {
            if ( filter.retain( iterator.next() ) )
            {
                iterator.remove();
            }
        }
        
        return collection;
    }","@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      LinkedList<Integer> linkedList0 = new LinkedList<Integer>();
      LinkedList<Integer> linkedList1 = FilterUtils.inverseFilter(linkedList0, (Filter<Integer>) null);
      assertSame(linkedList0, linkedList1);
  }","Filters the given collection using the given {@link Filter} retaining only items which does NOT pass the filter evaluation.@param <T> type. @param collection the {@link Collection}. @param filter the filter. @param <V> the type of the collection members. @return the inverse filtered collection, null if any input parameter is null."
"public CORSConfigBuilder withAllowedOrigins(Collection<String> allowedOrigins) {
        if (allowedOrigins != null) {
            for (String allowedOrigin : allowedOrigins) {
                if (!allowedOrigin.startsWith(""http://"") && !allowedOrigin.startsWith(""https://"")) {
                    throw new IllegalArgumentException(allowedOrigin + "" is invalid: origins much have an http:// or https:// prefix"");
                }
                if (allowedOrigin.lastIndexOf('/') > 8) {
                    throw new IllegalArgumentException(allowedOrigin + "" is invalid: origins should not have any paths. Example origin: https://example.org"");
                }
            }
        }
        this.allowedOrigins = allowedOrigins;
        return this;
    }","@Test(timeout = 4000)
  public void test07()  throws Throwable  {
      CORSConfigBuilder cORSConfigBuilder0 = CORSConfigBuilder.disabled();
      // Undeclared exception!
      try { 
        cORSConfigBuilder0.withAllOriginsAllowed();
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""io.muserver.rest.CORSConfigBuilder"", e);
      }
  }","The origin values that CORS requests are allowed for, or null to allow all origins. @param allowedOrigins Allowed origins, such as <code>https:example.org<code> or <code>http:localhost:8080<code> @return This builder"
"private static int fontStyleToInt(FontStyle style) {
        switch (style) {
        case PLAIN:
            return java.awt.Font.PLAIN;
        case BOLD:
            return java.awt.Font.BOLD;
        case ITALIC:
            return java.awt.Font.ITALIC;
        default:
            return java.awt.Font.PLAIN;
        }
    }","@Test(timeout = 4000)
  public void test12()  throws Throwable  {
      FontStyle fontStyle0 = FontStyle.ITALIC;
      Font font0 = new Font("""", fontStyle0, 0.0);
      font0.getName();
      assertEquals(0.0, font0.getSize(), 0.01);
  }",Return a java.awt.Font style constant from FontStyle.@param style FontStyle value. @return A java.awt.Font style constant.
"@Override
  public ByteBuffer getBytes() {
    ByteBuffer bb = ByteBuffer.allocate(HEADER_LENGTH + getTotalbody());
    bb.put(magic.getMagic());
    bb.put(opcode.getOpcode());
    bb.putShort(keylength);
    bb.put(extralength);
    bb.put(datatype);
    bb.putShort(vbucket);
    bb.putInt(totalbody);
    bb.putInt(opaque);
    bb.putLong(cas);

    if (hasFlags) {
      int flag = 0;
      for (int i = 0; i < flagList.size(); i++) {
        flag |= flagList.get(i).getFlags();
      }
      bb.putInt(flag);
    }
    bb.put(name.getBytes());
    if (hasBackfill) {
      bb.putLong(backfilldate);
    }
    if (hasVBucketList) {
      bb.putShort((short) vblist.length);
      for (int i = 0; i < vblist.length; i++) {
        bb.putShort(vblist[i]);
      }
    }
    if (hasVBucketCheckpoints) {
      bb.putShort((short)vBucketCheckpoints.size());
      for (Short vBucket : vBucketCheckpoints.keySet()) {
        bb.putShort(vBucket);
        bb.putLong(vBucketCheckpoints.get(vBucket));
      }
    }

    return (ByteBuffer) bb.flip();
  }","@Test(timeout = 4000)
  public void test3()  throws Throwable  {
      RequestMessage requestMessage0 = new RequestMessage();
      TapOpcode tapOpcode0 = TapOpcode.REQUEST;
      requestMessage0.opcode = tapOpcode0;
      TapMagic tapMagic0 = TapMagic.PROTOCOL_BINARY_REQ;
      requestMessage0.setMagic(tapMagic0);
      ByteBuffer byteBuffer0 = requestMessage0.getBytes();
      assertEquals(""java.nio.HeapByteBuffer[pos=0 lim=59 cap=60]"", byteBuffer0.toString());
  }",Encodes the message into binary.
"public static byte[] compress(byte[] input) throws IOException
    {
        // Destination where compressed data will be stored.
        ByteArrayOutputStream baos = new ByteArrayOutputStream();

        // Create a compressor.
        Deflater deflater = createDeflater();
        DeflaterOutputStream dos = new DeflaterOutputStream(baos, deflater);

        // Compress the data.
        //
        // Some other implementations such as Jetty and Tyrus use
        // Deflater.deflate(byte[], int, int, int) with Deflate.SYNC_FLUSH,
        // but this implementation does not do it intentionally because the
        // method and the constant value are not available before Java 7.
        dos.write(input, 0, input.length);
        dos.close();

        // Release the resources held by the compressor.
        deflater.end();

        // Retrieve the compressed data.
        return baos.toByteArray();
    }","@Test(timeout = 4000)
  public void test0()  throws Throwable  {
      byte[] byteArray0 = new byte[2];
      byte[] byteArray1 = DeflateCompressor.compress(byteArray0);
      assertEquals(2, byteArray1.length);
  }","Destination where compressed data will be stored.
Create a compressor.
Compress the data.
Some other implementations such as Jetty and Tyrus use
Deflater.deflate(byte[], int, int, int) with Deflate.SYNC_FLUSH,
but this implementation does not do it intentionally because the
method and the constant value are not available before Java 7.
Release the resources held by the compressor.
Retrieve the compressed data."
"@SuppressWarnings(""SimplifiableIfStatement"")
    public static boolean nullSafeEquals(Object o1, Object o2) {
        if (o1 == o2) {
            return true;
        }
        if (o1 == null || o2 == null) {
            return false;
        }
        return o1.equals(o2);
    }","@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      ObjectUtils objectUtils0 = new ObjectUtils();
      // Undeclared exception!
      try { 
        ObjectUtils.nullSafeEquals((Object) null, objectUtils0);
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""com.contrastsecurity.cassandra.migration.utils.ObjectUtils"", e);
      }
  }","Determine if the given objects are equal, returning {@code true} if both are {@code null} or {@code false} if only one is {@code null}.@param o1 first Object to compare @param o2 second Object to compare @return whether the given objects are equal"
"public void execute() throws BadgerException {
		if (inputFiles != null && inputFiles.length > 0) {
			checkOutputDir();
			for (File inputXml : inputFiles) {
				if (inputXml != null && inputXml.canRead() && inputXml.isFile()) {
					File output = getOutputFile(inputXml);
					transform(inputXml, output);
				} else {
					LOGGER.log(Level.WARNING, ""Badger cannot read input XML file {0}"", inputXml);
				}
			}
		} else {
			LOGGER.log(Level.INFO, ""No reports found, not building badges"");
		}
	}","@Test(timeout = 4000)
  public void test3()  throws Throwable  {
      Badger badger0 = new Badger();
      File[] fileArray0 = new File[3];
      MockFile mockFile0 = new MockFile(""n)(~O"", ""X@9w"");
      fileArray0[0] = (File) mockFile0;
      badger0.setOutputDir(fileArray0[0]);
      badger0.setInputXml(fileArray0);
      // Undeclared exception!
      try { 
        badger0.execute();
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""com.github.bordertech.buildtools.Badger"", e);
      }
  }",Generate badges configured in the current state of this instance. Assumes the inputs and outputs have been set. @throws BadgerException if something goes wrong to report to the invoker.
"public static String popStartsWith( Collection<String> collection, String prefix )
    {
        Iterator<String> iterator = collection.iterator();
        
        while ( iterator.hasNext() )
        {
            String element = iterator.next();
            
            if ( element != null && element.startsWith( prefix ) )
            {
                iterator.remove();
                return element;
            }
        }
        
        return null;
    }","@Test(timeout = 4000)
  public void test00()  throws Throwable  {
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.offer((String) null);
      // Undeclared exception!
      try { 
        CollectionUtils.popStartsWith(linkedList0, (String) null);
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
      }
  }","Searches for and returns the first string which starts with the given prefix. Removes the match from the collection. @param collection the collection. @param prefix the string prefix. @return a string, or null if no matches."
,"@Test(timeout = 4000)
  public void test05()  throws Throwable  {
      HashMap<String, List<String>> hashMap0 = new HashMap<String, List<String>>();
      hashMap0.put(""X-Contentful-RateLimit-Hour-Limit"", (List<String>) null);
      RateLimits.DefaultParser rateLimits_DefaultParser0 = new RateLimits.DefaultParser();
      // Undeclared exception!
      try { 
        rateLimits_DefaultParser0.parse(hashMap0);
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""com.contentful.java.cma.model.RateLimits$DefaultParser"", e);
      }
  }",
"public CMAPersonalAccessToken addScope(Scope scope) {
    if (scopes == null) {
      scopes = new ArrayList<Scope>();
    }

    scopes.add(scope);
    return this;
  }","@Test(timeout = 4000)
  public void test3()  throws Throwable  {
      CMAPersonalAccessToken cMAPersonalAccessToken0 = new CMAPersonalAccessToken();
      CMAPersonalAccessToken.Scope cMAPersonalAccessToken_Scope0 = CMAPersonalAccessToken.Scope.Manage;
      // Undeclared exception!
      try { 
        cMAPersonalAccessToken0.addScope(cMAPersonalAccessToken_Scope0);
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""com.contentful.java.cma.model.CMAPersonalAccessToken"", e);
      }
  }",Add a new scope to the list of scopes. Creates a new list of scopes if no scopes found.@param scope the new scope to be added. @return this instance for chaining.
"protected void printHorizontalSeparator(final StringBuilder stringBuilder, final char leftConnector,
            final char middleConnector,
            final char rightConnector) {
        if (isPrintLeftBorder()) {
            stringBuilder.append(leftConnector);
            append(stringBuilder, borderConfiguration.getHorizontalLine(), getColumnSpacing());
        }
        append(stringBuilder, borderConfiguration.getHorizontalLine(), columnWidths[0]);
        for (int i = 1; i < columnCount; i++) {
            if (isPrintColumnSeparators()) {
                append(stringBuilder, borderConfiguration.getHorizontalLine(), getColumnSpacing());
                stringBuilder.append(middleConnector);
                append(stringBuilder, borderConfiguration.getHorizontalLine(), getColumnSpacing());
            }
            append(stringBuilder, borderConfiguration.getHorizontalLine(), columnWidths[i]);
        }
        if (isPrintRightBorder()) {
            append(stringBuilder, borderConfiguration.getHorizontalLine(), getColumnSpacing());
            stringBuilder.append(rightConnector);
        }
        stringBuilder.append('\n');
    }","@Test(timeout = 4000)
  public void test19()  throws Throwable  {
      ConsoleTable consoleTable0 = new ConsoleTable(38);
      consoleTable0.setPrintTopBorder(false);
      StringBuilder stringBuilder0 = new StringBuilder();
      // Undeclared exception!
      try { 
        consoleTable0.appendTo(stringBuilder0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 38
         //
         verifyException(""de.chrlembeck.util.console.ConsoleTable"", e);
      }
  }","Fügt einen horizontalen Trennstrich inclusive Zeilenumbruch ein. @param stringBuilder StringBuilder, an den der Trennstrich angehängt werden soll. @param leftConnector Symbol für den Anschluss des linken Tabellenrands. @param middleConnector Symbol für den Anschluss von Rahmen in der Mitte. @param rightConnector Symbol für den Anschluss des rechten Tabellenrands."
"public WebSocketHandlerBuilder withWebSocketFactory(MuWebSocketFactory factory) {
        Mutils.notNull(""factory"", factory);
        this.factory = factory;
        return this;
    }","@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      MuWebSocketFactory muWebSocketFactory0 = mock(MuWebSocketFactory.class, new ViolatedAssumptionAnswer());
      WebSocketHandlerBuilder webSocketHandlerBuilder0 = WebSocketHandlerBuilder.webSocketHandler(muWebSocketFactory0);
      // Undeclared exception!
      try { 
        webSocketHandlerBuilder0.build();
        fail(""Expecting exception: NoClassDefFoundError"");
      
      } catch(NoClassDefFoundError e) {
         //
         // io/netty/handler/codec/http/HttpHeaders
         //
         verifyException(""io.muserver.WebSocketHandlerBuilder"", e);
      }
  }","<p>Sets the factory that decides whether to create a websocket connection for a request.<p> <p>Note that the factory will only be called if the request is a websocket upgrade request.<p> @param factory A factory that creates websockets, or returns null if the websocket connection shouldn't be created. @return This builder"
"public boolean checkEndsWith(String str, String end) {
		int endLen = end.length();
		return str.regionMatches(!sensitive, str.length() - endLen, end, 0, endLen);
	}","@Test(timeout = 4000)
  public void test04()  throws Throwable  {
      Case case0 = Case.SENSITIVE;
      // Undeclared exception!
      try { 
        case0.checkEndsWith("""", """");
        fail(""Expecting exception: ArithmeticException"");
      
      } catch(ArithmeticException e) {
         //
         // / by zero
         //
         verifyException(""org.xenei.classpathutils.Case"", e);
      }
  }","Checks if one string ends with another using the case-sensitivity rule. <p> This method mimics {@link String#endsWith} but takes case-sensitivity into account. @param str the string to check, not null @param end the end to compare against, not null @return true if equal using the case rules @throws NullPointerException if either string is null"
"public static <T> void removeAll( List<T> list, List<Integer> indexes )
    {
        if ( list == null || indexes == null )
        {
            return;
        }
        
        Collections.sort( indexes, Collections.reverseOrder() );
        
        final int size = list.size();
        
        for ( Integer index : indexes )
        {
            if ( index >= 0 && index < size )
            {
                list.remove( (int) index );
            }
        }
    }","@Test(timeout = 4000)
  public void test16()  throws Throwable  {
      List<Integer> list0 = ListUtils.getClosedOpenList(0, 18);
      LinkedList<Object> linkedList0 = new LinkedList<Object>();
      // Undeclared exception!
      try { 
        ListUtils.removeAll((List<Object>) linkedList0, list0);
        fail(""Expecting exception: IndexOutOfBoundsException"");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 0, Size: 0
         //
         verifyException(""java.util.LinkedList"", e);
      }
  }",Removes from the given list the elements at the given indexes. Ignores indexes which are out of bounds of list. @param <T> type. @param list the list to remove elements from. @param indexes the indexes for the elements to remove.
"public Extension getExtension() {
    if (extension == null) {
      extension = new Extension();
    }

    return extension;
  }","@Test(timeout = 4000)
  public void test5()  throws Throwable  {
      CMAUiExtension cMAUiExtension0 = new CMAUiExtension();
      String string0 = cMAUiExtension0.toString();
      assertEquals(""CMAUiExtension { CMAResource { system = CMASystem { type = UiExtension } } extension = null }"", string0);
  }",@return the extension description part of the UI extension.
,"@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      ResourceUsage resourceUsage0 = new ResourceUsage(1240L, (-3011));
      int int0 = resourceUsage0.getNumResources();
      assertEquals(1240L, resourceUsage0.getTime());
  }",
"private static List<Triangle2D> internalTriangulate(
            final List<Point2D> verticesCopy, final List<int[]> indices,
            final List<Point2D> originalVertices) throws TriangulatorException {
        if (verticesCopy.size() < MIN_VERTICES) {
            throw new TriangulatorException();
        }

        final List<Triangle2D> result = new LinkedList<>();

        boolean madeCut;

        Triangle2D triangle = null;

        // Second, apply algorithm
        while (verticesCopy.size() > MIN_VERTICES) {
            madeCut = false;
            final int lastElement = verticesCopy.size() - 1;
            for (int i = 0; i <= lastElement; i++) {

                if (i == 0) {
                    if (triangle == null) {
                        // instantiate triangle if not already instantiated
                        triangle = new Triangle2D(verticesCopy.get(lastElement),
                                verticesCopy.get(0), verticesCopy.get(1));
                    } else {
                        triangle.setVertices(verticesCopy.get(lastElement),
                                verticesCopy.get(0), verticesCopy.get(1));
                    }
                } else if (i == lastElement) {
                    triangle.setVertices(verticesCopy.get(lastElement - 1),
                            verticesCopy.get(lastElement),
                            verticesCopy.get(0));
                } else {
                    triangle.setVertices(verticesCopy.get(i - 1),
                            verticesCopy.get(i), verticesCopy.get(i + 1));
                }

                if (isEar(triangle, verticesCopy)) {
                    // If it is an ear, we build a face out of the triangle being
                    // cut and remove it from polygon by cutting it
                    result.add(triangle);
                    // so that it cannot be reused after being added
                    triangle = null;

                    // cut ear
                    verticesCopy.remove(i);
                    madeCut = true;

                    // Leave from FOR loop to loop again to new reduced vertices set
                    break;
                }
            }

            // if arrived here but no cut was made and polygon size contains
            // more than 3 vertices, then the algorithm failed for some reason
            if (!madeCut) {
                throw new TriangulatorException();
            }
        }

        // instantiate final triangle
        triangle = new Triangle2D(verticesCopy.get(0),
                verticesCopy.get(1), verticesCopy.get(2));


        final boolean arePointsColinear = triangle.areVerticesColinear();

        // only add final triangle if not co-linear (area greater than small
        // threshold)
        if (!arePointsColinear)
            result.add(triangle);

        // add indices of triangles verticesCopy
        computeIndices(originalVertices, result, indices);

        return result;
    }","@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      VanGoghTriangulator2D vanGoghTriangulator2D0 = new VanGoghTriangulator2D();
      HomogeneousPoint2D homogeneousPoint2D0 = new HomogeneousPoint2D(3, 3, 3);
      Triangle2D triangle2D0 = new Triangle2D(homogeneousPoint2D0, homogeneousPoint2D0, homogeneousPoint2D0);
      List<Point2D> list0 = triangle2D0.getVertices();
      LinkedList<Point2D> linkedList0 = new LinkedList<Point2D>(list0);
      linkedList0.add((Point2D) homogeneousPoint2D0);
      // Undeclared exception!
      try { 
        vanGoghTriangulator2D0.triangulate((List<Point2D>) linkedList0);
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""com.irurueta.geometry.VanGoghTriangulator2D"", e);
      }
  }","Internal method that computes the actual triangulation.@param verticesCopy List of points considered as verticesCopy of a polygon. This list will be modified after execution of this method. @param indices List where indices of original verticesCopy will be stored. This list can be used to refer to the original order of verticesCopy. Notice that verticesCopy indices might be repeated because verticesCopy might appear in more than one triangle after triangulation. If this parameter is null, indices won't be stored in this list. @param originalVertices Reference to original list of vertices that won't be modified. @return List of triangles forming the polygon that has been triangulated. @throws TriangulatorException Raised if triangulation cannot be done. Usually this indicates numerical instability or polygon degeneracy.Second, apply algorithm
instantiate final triangle
only add final triangle if not co-linear (area greater than small
threshold)
add indices of triangles verticesCopy"
"private static String split(String s) {
        int i = s.lastIndexOf('.');
        if (i < 0)
            return s;
        else
            return s.substring(i + 1);
    }","@Test(timeout = 4000)
  public void test3()  throws Throwable  {
      RtfParserException rtfParserException0 = new RtfParserException();
      RtfParserException rtfParserException1 = new RtfParserException(rtfParserException0);
      String string0 = rtfParserException1.toString();
      assertEquals("".RtfParserException: org.evosuite.runtime.mock.java.lang.MockThrowable"", string0);
  }",Removes everything in a String that comes before a '.' @param s the original string @return the part that comes after the dot
,"@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      // Undeclared exception!
      try { 
        StripedLock.create();
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // storage power must be in [1..6]
         //
         verifyException(""com.github.edgar615.util.concurrent.StripedLock"", e);
      }
  }",
"public boolean transition(int oldSnapshot, int newState) {
        int oldState = oldSnapshot & STATE_MASK;
        // Validate legal transition.
        if (shouldValidate) {
            if (!isValidTransition(oldState, newState)) {
                throw new IllegalArgumentException(String.format(""Can't transition from state %d to %d."", oldState, newState));
            }
        }
        int newSnapshot = ((oldSnapshot & INDEX_MASK) + INDEX_INCREMENTER) | newState;

        // The common case: we were asked to update something valid, and nothing invalidated our starting assumptions,
        // so we succeeded.
        if (stateSnapshot.compareAndSet(oldSnapshot, newSnapshot)) {
            if (listener != null) {
                // Don't report (non-)events where state wasn't updated.
                if (oldState != newState) {
                    listener.onCircuitTransition(this, oldState, newState);
                }
            }
            return true;

        // The second most common case: the atomic couldn't be updated, but it doesn't matter, because the
        // request was redundant (state was already correct). This happens when multiple threads ask for
        // the same transition.
        } else if ((stateSnapshot.get() & STATE_MASK) == newState) {
            return true;
        }

        // Otherwise our caller asked for something we can't honor. Typically this is because concurrency
        // invalidated the caller's view of what our current state was.
        return false;
    }","@Test(timeout = 4000)
  public void test28()  throws Throwable  {
      Circuit circuit0 = new Circuit((Circuit.Listener) null);
      
      boolean boolean0 = circuit0.transition(0, 1);
      assertTrue(boolean0);
  }","<p>Attempt to move our state machine to a new state. This method should be called by {@link TransitionPolicy} objects, not the general public. (For direct manipulation of a circuit breaker, see {@link CircuitBreaker#directTransition(int, boolean)} instead.)<p><p>The request to transition will succeed if:<p> <ul> <li>The state machine is already in the requested state, making the transition redundant<li> <li><strong>OR<strong> the state has not changed since we last fetched it with {@link #getStateSnapshot()}<li> <ul><p>If {@link #shouldValidate} is true, then the correctness of old and new state are checked with each call, and an {@link IllegalArgumentException} is thrown if anomalies are detected. (This correctness is not evaluated against the actual state of the circuit, but rather against the asserted oldSnapshot. In other words, it can only generate an exception if the caller is coded wrong, not if the caller is unaware of the current state of the circuit.) This may be helpful while developing a new {@link CircuitBreaker}.<p>@param oldSnapshot Asserts that the circuit is currently in the state described by oldSnapshot. This value is returned by {@link #getStateSnapshot()}; it is more than one of the state constants ({@link #OPEN}, {@link #CLOSED}, etc). @param newState The new state that's desired. See {@link #OPEN}, {@link #CLOSED}, etc. @return true if the circuit is in the desired state when the function completes, false if not.Validate legal transition.
The common case: we were asked to update something valid, and nothing invalidated our starting assumptions,
so we succeeded.
Otherwise our caller asked for something we can't honor. Typically this is because concurrency
invalidated the caller's view of what our current state was."
"private static List<Triangle3D> internalTriangulate(
            final List<Point3D> verticesCopy, final List<int[]> indices,
            final List<Point3D> originalVertices) throws TriangulatorException {
        if (verticesCopy.size() < MIN_VERTICES) {
            throw new TriangulatorException();
        }

        final List<Triangle3D> result = new LinkedList<>();

        boolean isEar;
        boolean madeCut;

        Triangle3D triangle = null;

        // Second, apply algorithm
        while (verticesCopy.size() > MIN_VERTICES) {
            madeCut = false;
            final int lastElement = verticesCopy.size() - 1;
            for (int i = 0; i <= lastElement; i++) {


                if (i == 0) {
                    if (triangle == null) {
                        // instantiate triangle if not already instantiated
                        triangle = new Triangle3D(verticesCopy.get(lastElement),
                                verticesCopy.get(0), verticesCopy.get(1));
                    } else {
                        triangle.setVertices(verticesCopy.get(lastElement),
                                verticesCopy.get(0), verticesCopy.get(1));
                    }
                } else if (i == lastElement) {
                    triangle.setVertices(verticesCopy.get(lastElement - 1),
                            verticesCopy.get(lastElement),
                            verticesCopy.get(0));
                } else {
                    triangle.setVertices(verticesCopy.get(i - 1),
                            verticesCopy.get(i), verticesCopy.get(i + 1));
                }

                try {
                    isEar = isEar(triangle, verticesCopy);
                } catch (CoincidentPointsException e) {
                    isEar = false;
                }

                if (isEar) {
                    // If it is an ear, we build a face out of the triangle being
                    // cut and remove it from polygon by cutting it
                    result.add(triangle);
                    // so that it cannot be reused after being added
                    triangle = null;

                    // cut ear
                    verticesCopy.remove(i);
                    madeCut = true;

                    // Leave from FOR loop to loop again to new reduced verticesCopy set
                    break;
                }
            }

            // if arrived here but no cut was made and polygon size contains
            // more than 3 verticesCopy, then the algorithm failed for some reason
            if (!madeCut) {
                throw new TriangulatorException();
            }
        }

        // instantiate final triangle
        triangle = new Triangle3D(verticesCopy.get(0),
                verticesCopy.get(1), verticesCopy.get(2));


        final boolean arePointsColinear = triangle.areVerticesColinear();

        // only add final triangle if not co-linear (area greater than small
        // threshold)
        if (!arePointsColinear) {
            result.add(triangle);
        }

        // add indices of triangles verticesCopy
        computeIndices(originalVertices, result, indices);

        return result;
    }","@Test(timeout = 4000)
  public void test4()  throws Throwable  {
      VanGoghTriangulator3D vanGoghTriangulator3D0 = new VanGoghTriangulator3D();
      Point3D point3D0 = Point3D.create();
      Triangle3D triangle3D0 = new Triangle3D(point3D0, point3D0, point3D0);
      List<Point3D> list0 = triangle3D0.getVertices();
      // Undeclared exception!
      try { 
        vanGoghTriangulator3D0.triangulate(list0);
        fail(""Expecting exception: IndexOutOfBoundsException"");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 2, Size: 2
         //
         verifyException(""java.util.ArrayList"", e);
      }
  }","Internal method that computes the actual triangulation.@param verticesCopy List of points considered as verticesCopy of a polygon. This list will be modified after execution of this method @param indices List where indices of original verticesCopy will be stored. This list can be used to refer to the original order of verticesCopy. Notice that verticesCopy indices might be repeated because verticesCopy might appear in more than one triangle after triangulation. If this parameter is null, indices won't be stored in this list. @param originalVertices Reference to original list of vertices that won't be modified. @return List of triangles forming the polygon that has been triangulated. @throws TriangulatorException Raised if triangulation cannot be done. Usually this indicates numerical instability or polygon degeneracy.Second, apply algorithm
instantiate final triangle
only add final triangle if not co-linear (area greater than small
threshold)
add indices of triangles verticesCopy"
"public static String getImageUrl(String pid, ImageSize imageSize, boolean https) {
        pid = pid.trim();
        String size = imageSize.name();
        // 传递 pid
        Pattern p = Pattern.compile(""^[a-zA-Z0-9]{32}$"");
        Matcher m = p.matcher(pid);

        if (m.matches()) {
            CRC32 crc32 = new CRC32();
            crc32.update(pid.getBytes());
            return (https ? ""https"" : ""http"") + ""://"" + (https ? ""ws"" : ""ww"")
                    + ((crc32.getValue() & 3) + 1) + "".sinaimg.cn/"" + size
                    + ""/"" + pid + ""."" + (pid.charAt(21) == 'g' ? ""gif"" : ""jpg"");
        }
        // 传递 url
        String url = pid;
        Pattern p1 = Pattern.compile(""^(https?://[a-z]{2}d.sinaimg.cn/)(large|bmiddle|mw1024|mw690|small|square|thumb180|thumbnail)(/[a-z0-9]{32}.(jpg|gif))$"");
        Matcher m1 = p1.matcher(url);
        if (m1.find()) {
            return m.group(1) + size + m.group(3);
        }
        return null;
    }","@Test(timeout = 4000)
  public void test3()  throws Throwable  {
      ImageSize imageSize0 = ImageSize.square;
      String string0 = WbpUtils.getImageUrl(""00000000000000000000000000000000"", imageSize0, true);
      assertEquals(""https://ws0.sinaimg.cn/square/00000000000000000000000000000000.jpg"", string0);
  }","本方法来自 @dong4j：https:github.comdong4j <p> Gets image url.@param pid the pid @param imageSize the imageSize @param https the https @return the image url传递 pid
传递 url"
"public CMAEnvironmentStatus getStatus() {
    final CMALink link = system.getEnvironmentalStatus();
    if (link == null) {
      return null;
    }

    final String id = link.getId().toLowerCase();

    for (final CMAEnvironmentStatus status : CMAEnvironmentStatus.values()) {
      final String statusName = status.name().toLowerCase();
      if (statusName.equals(id)) {
        return status;
      }
    }

    return null;
  }","@Test(timeout = 4000)
  public void test2()  throws Throwable  {
      CMAEnvironment cMAEnvironment0 = new CMAEnvironment();
      // Undeclared exception!
      try { 
        cMAEnvironment0.getStatus();
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""com.contentful.java.cma.model.CMAEnvironment"", e);
      }
  }",Return the state of this environment@return one of {@link CMAEnvironmentStatus} to indicate the status of the environment.
"@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((res == null) ? 0 : res.hashCode());
		result = prime * result + (hasError() ? 1 : 0);
		return result;
	}","@Test(timeout = 4000)
  public void test09()  throws Throwable  {
      MockThrowable mockThrowable0 = new MockThrowable(""null"");
      Result<Result<Integer>> result0 = new Result<Result<Integer>>((Throwable) mockThrowable0);
      // Undeclared exception!
      try { 
        result0.hashCode();
        fail(""Expecting exception: ArithmeticException"");
      
      } catch(ArithmeticException e) {
         //
         // / by zero
         //
         verifyException(""com.aegisql.util.function.Result"", e);
      }
  }",(non-Javadoc) @see java.lang.Object#hashCode()
"private int privateCompare (TreeNode o1, TreeNode o2)
	{
		// same object?
		if (o1 == o2)
			return 0;
		
		int t = o2.getType ();
		if (t != o1.getType ())
			// text nodes always smaller than document nodes
			return t == TreeNode.TEXT_NODE ? 1 : -1;
		
		if (t == TreeNode.DOC_NODE)
		{
			// get the subtree sizes
			int sub1 = ((DocumentNode) o1).getSizeSubtree ();
			int sub2 = ((DocumentNode) o2).getSizeSubtree ();
			
			// first based on subtree
			if (sub1 < sub2)
				return -1;
			if (sub1 > sub2)
				return 1;
			
			// in case of equality compare weights
			double w1 = o1.getWeight (), w2 = o2.getWeight ();
			if (w1 < w2)
				return -1;
			if (w1 > w2)
				return 1;
		
			int a1 = ((DocumentNode) o1).getAttributes ().size (), a2 = ((DocumentNode) o2)
				.getAttributes ().size ();
			
			// if that also equals, compare number of arguments
			if (a1 < a2)
				return -1;
			if (a1 > a2)
			return 1;
		}
		else
		{
			// in text nodes we can only compare the weights
			double w1 = o1.getWeight (), w2 = o2.getWeight ();
			if (w1 < w2)
				return -1;
			if (w1 > w2)
				return 1;
			
		}
		
		// last but not least: compare xpaths
		return o1.getXPath ().compareTo (o2.getXPath ());
	}","@Test(timeout = 4000)
  public void test2()  throws Throwable  {
      TreeNodeComparatorBySubtreeSize treeNodeComparatorBySubtreeSize0 = new TreeNodeComparatorBySubtreeSize();
      // Undeclared exception!
      try { 
        treeNodeComparatorBySubtreeSize0.compare((TreeNode) null, (TreeNode) null);
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""de.unirostock.sems.xmlutils.ds.TreeNodeComparatorBySubtreeSize"", e);
      }
  }","really compares the nodes. @param o1 node one @param o2 node two @return the ascending ordersame object?
last but not least: compare xpaths"
,"@Test(timeout = 4000)
  public void test2()  throws Throwable  {
      GossipSettings gossipSettings0 = new GossipSettings(4662, 4662);
      int int0 = gossipSettings0.getGossipInterval();
      assertEquals(4662, gossipSettings0.getCleanupInterval());
  }",
"public void closestPoint(final Point3D point, final Point3D result) {
        closestPoint(point, result, DEFAULT_THRESHOLD);
    }","@Test(timeout = 4000)
  public void test30()  throws Throwable  {
      HomogeneousPoint3D homogeneousPoint3D0 = new HomogeneousPoint3D();
      Triangle3D triangle3D0 = new Triangle3D(homogeneousPoint3D0, homogeneousPoint3D0, homogeneousPoint3D0);
      // Undeclared exception!
      try { 
        triangle3D0.closestPoint((Point3D) homogeneousPoint3D0, (Point3D) homogeneousPoint3D0);
        fail(""Expecting exception: NoClassDefFoundError"");
      
      } catch(NoClassDefFoundError e) {
         //
         // com/irurueta/algebra/AlgebraException
         //
         verifyException(""com.irurueta.geometry.Triangle3D"", e);
      }
  }",Computes the point which is locus of this triangle closest to provided point and stores the result in provided result point.@param point Point to be checked. @param result Point where result will be stored.
"@Override
	public String toString() {
		return ""EvalStatus [success="" + success() + (th==null ? """" : ""; unhandled error found: ""+th.getMessage() ) + ""]"";
	}","@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      EvalStatus evalStatus0 = new EvalStatus((Throwable) null);
      // Undeclared exception!
      try { 
        evalStatus0.toString();
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""com.aegisql.util.function.EvalStatus"", e);
      }
  }",(non-Javadoc) @see com.aegisql.util.function.Result#toString()
,"@Test(timeout = 4000)
  public void test0()  throws Throwable  {
      Integer integer0 = new Integer(44);
      DefaultMapEntry<Integer, Integer> defaultMapEntry0 = new DefaultMapEntry<Integer, Integer>(integer0, integer0);
      String string0 = defaultMapEntry0.toString();
      assertEquals(""null=44"", string0);
  }",
"public static boolean isNotEmpty(Collection<?> collection) {
        return collection != null && !collection.isEmpty();
    }","@Test(timeout = 4000)
  public void test2()  throws Throwable  {
      // Undeclared exception!
      try { 
        QyWeixinRobotUtil.isEmpty((Collection<?>) null);
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
      }
  }",集合判非空 @param collection 集合 @return true非空
"public static <L, R> Pair<L, R> of(L left, R right) {
        Pair<L, R> pair = new Pair<L, R>();
        pair.left = left;
        pair.right = right;
        return pair;
    }","@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      Integer integer0 = new Integer(2152);
      Pair<Integer, Integer> pair0 = Pair.of(integer0, integer0);
      Integer integer1 = pair0.getLeft();
      assertNull(integer1);
  }",Creates a new pair of these values.@param left The left side of the pair. @param right The right side of the pair. @return The pair.
"public static double convertToRadians(final double degrees) {
        return degrees / 180.0 * Math.PI;
    }","@Test(timeout = 4000)
  public void test4()  throws Throwable  {
      double double0 = Utils.convertToRadians((-1335.8));
      assertEquals((-1901.2866776461628), double0, 0.01);
  }",Converts provided value from degrees to radians. @param degrees Angle in degrees. @return Converted angle in radians.
,"@Test(timeout = 4000)
  public void test10()  throws Throwable  {
      CMAAsset cMAAsset0 = new CMAAsset();
      // Undeclared exception!
      try { 
        cMAAsset0.toString();
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""com.contentful.java.cma.model.CMAAsset$Fields"", e);
      }
  }",
,"@Test(timeout = 4000)
  public void test4()  throws Throwable  {
      Integer integer0 = new Integer(1290);
      MockException mockException0 = new MockException();
      XeroRateLimitException xeroRateLimitException0 = new XeroRateLimitException(1290, integer0, integer0, integer0, (Long) null, "" : "", mockException0);
      xeroRateLimitException0.getMessage();
      assertEquals(0, xeroRateLimitException0.getStatusCode());
  }",
,"@Test(timeout = 4000)
  public void test10()  throws Throwable  {
      CallbackEvent.EventType callbackEvent_EventType0 = CallbackEvent.EventType.FAIL;
      CallbackEvent callbackEvent0 = new CallbackEvent(""c5^5}]-xCk:.]d^"", callbackEvent_EventType0, ""c5^5}]-xCk:.]d^"", ""c5^5}]-xCk:.]d^"", ""c5^5}]-xCk:.]d^"");
      String string0 = callbackEvent0.getRequestID();
      assertNull(string0);
  }",
"public String htmlEncode( Object object )
    {
        return object != null ? StringEscapeUtils.escapeHtml4( String.valueOf( object ) ) : null;
    }","@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      Encoder encoder0 = new Encoder();
      Object object0 = new Object();
      // Undeclared exception!
      try { 
        encoder0.htmlEncode(object0);
        fail(""Expecting exception: NoClassDefFoundError"");
      
      } catch(NoClassDefFoundError e) {
         //
         // org/apache/commons/lang3/StringEscapeUtils
         //
         verifyException(""org.hisp.dhis.commons.util.Encoder"", e);
      }
  }",HTML-escapes the String representation of the given Object. @param object the Object. @return an HTML-escaped String representation.
"public static String getUUID() {
        return UUID.randomUUID().toString().replaceAll(""-"", """");
    }","@Test(timeout = 4000)
  public void test4()  throws Throwable  {
      // Undeclared exception!
      try { 
        UUIDUtils.getUUID(609);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 609
         //
         verifyException(""com.github.chengtengfei.util.UUIDUtils"", e);
      }
  }",获得一个去掉“-”符号的UUID@return StringUUID
"public CMAEditorInterface addControl(Control control) {
    if (controls == null) {
      controls = new ArrayList<Control>();
    }

    controls.add(control);
    return this;
  }","@Test(timeout = 4000)
  public void test07()  throws Throwable  {
      CMAEditorInterface.Control cMAEditorInterface_Control0 = new CMAEditorInterface.Control();
      CMAEditorInterface cMAEditorInterface0 = new CMAEditorInterface();
      // Undeclared exception!
      try { 
        cMAEditorInterface0.addControl(cMAEditorInterface_Control0);
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""com.contentful.java.cma.model.CMAEditorInterface"", e);
      }
  }","Adds a new control to the list of controls. <p> It might create a new list of controls, if no list is created.@param control to be added to the list. @return this instance for chaining."
"public int getNumResources() {
		return ranges == null ? 0 : ranges.getNumItems();
	}","@Test(timeout = 4000)
  public void test6()  throws Throwable  {
      SingleProfileEntry singleProfileEntry0 = new SingleProfileEntry(3223L);
      // Undeclared exception!
      try { 
        singleProfileEntry0.getNumResources();
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""me.marcosassuncao.servsim.profile.SingleProfileEntry"", e);
      }
  }",Gets the number of PEs associated with this entry @return the number of PEs
"public static String  getDeepValue(Map m, String namePath) {
		return getDeepValue(m,namePath,String.class);
	}","@Test(timeout = 4000)
  public void test09()  throws Throwable  {
      HashMap<String, String> hashMap0 = new HashMap<String, String>();
      hashMap0.put("""", """");
      Class<String> class0 = String.class;
      // Undeclared exception!
      try { 
        MapUtil.getDeepValue((Map) hashMap0, "".*~~fA<0MmY!UL^GpCG"", class0, (String) null);
        fail(""Expecting exception: ClassCastException"");
      
      } catch(ClassCastException e) {
         //
         // java.lang.String cannot be cast to java.util.Map
         //
         verifyException(""com.britesnow.snow.util.MapUtil"", e);
      }
  }","@param m the nested map @param namePath the namePath (i.e. ""product.name"")"
,"@Test(timeout = 4000)
  public void test0()  throws Throwable  {
      Object object0 = new Object();
      CDARichHyperLink cDARichHyperLink0 = new CDARichHyperLink(object0);
      Object object1 = cDARichHyperLink0.getData();
      assertNull(object1);
  }",
"public static final String toASCII(String in) {
        try {
            return IDN.toASCII(in);
        } catch (Exception e) {
            // let's continue with the character by character encoding hack.
        }
        final StringBuilder sb = new StringBuilder();
        for (int i=0;i<in.length();i++) {
            try {
                sb.append(IDN.toASCII(in.substring(i, i + 1)));
            }
            catch (Exception e) {}
        }
        if (sb.length() == 0) {
            throw new RuntimeException(""Unable to convert "" + in + "" to ASCII"");
        }
        return sb.toString();
    }","@Test(timeout = 4000)
  public void test0()  throws Throwable  {
      // Undeclared exception!
      try { 
        FakerIDN.toASCII("""");
        fail(""Expecting exception: RuntimeException"");
      
      } catch(RuntimeException e) {
         //
         // Unable to convert  to ASCII
         //
         verifyException(""com.github.javafaker.service.FakerIDN"", e);
      }
  }",{@link IDN#toASCII(String)} is too picky for our needs. It was throwing exceptions for fa.yml and he.yml as they're Bidi languages and something was causing them to die. This is kind of a brute force fix but it appears to fix the issue.
"public CMAContentType addField(CMAField field) {
    if (fields == null) {
      fields = new ArrayList<CMAField>();
    }

    fields.add(field);
    return this;
  }","@Test(timeout = 4000)
  public void test03()  throws Throwable  {
      CMAContentType cMAContentType0 = new CMAContentType();
      // Undeclared exception!
      try { 
        cMAContentType0.addField((CMAField) null);
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""com.contentful.java.cma.model.CMAContentType"", e);
      }
  }",Adds a new field.@param field CMAField instance @return this {@code CMAContentType}
"public static void main(final String[] args) throws Exception {
		if (args.length != 4) {
			Util.finishErr(""Bad arguments. Usage: \n\n "" + NewModelContract.class.getSimpleName()
					+ ""<owner_name> <owner_pass> <namespace_name> <benef_name> \n"", ERRCODE.ERROR);
			return;
		}
		try {
			Util.init();

			final String ownerName = args[0];
			final String ownerPass = args[1];
			final String namespaceName = args[2];
			final String benefName = args[3];

			final AccountID ownerID = ClientManagementLib.getAccountID(ownerName);
			if (ownerID == null) {
				Util.finishErr(""Invalid account"", ERRCODE.ERROR);
				return;
			}
			final PasswordCredential ownerCredential = new PasswordCredential(ownerPass);
			final AccountID benefID = ClientManagementLib.getAccountID(benefName);
			if (benefID == null) {
				Util.finishErr(""Invalid beneficiary account"", ERRCODE.ERROR);
				return;
			}
			final NamespaceID ownerNamespaceID = ClientManagementLib.getNamespaceID(ownerID, ownerCredential,
					namespaceName);
			if (ownerNamespaceID == null) {
				Util.finishErr(""Invalid namespace"", ERRCODE.ERROR);
				return;
			}
			final Map<MetaClassID, MetaClass> classesInNamespace = ClientManagementLib.getClassesInfoInNamespace(ownerID,
					ownerCredential, ownerNamespaceID);

			if (classesInNamespace != null && classesInNamespace.size() > 0) {
				final List<InterfaceInContract> newInterfacesInContract = new LinkedList<>();

				for (final Entry<MetaClassID, MetaClass> curClass : classesInNamespace.entrySet()) {
					final MetaClassID mclassID = curClass.getKey();
					final MetaClass mclass = curClass.getValue();
					System.out.println("" == Current class "" + mclass.getName() + "" ID "" + mclassID);
					final Set<String> propertiesNames = new HashSet<>();
					for (final Property prop : mclass.getProperties()) {
						propertiesNames.add(prop.getName());
					}

					final Set<String> opsSignature = new HashSet<>();
					final Set<OpImplementations> opImpls = new HashSet<>();
					for (final Operation op : mclass.getOperations()) {
						opsSignature.add(op.getNameAndDescriptor());

						final OpImplementations newOpImpls = new OpImplementations(op.getNameAndDescriptor(), 0, 0);
						opImpls.add(newOpImpls);
					}

					final Interface newIface = new Interface(ownerName, namespaceName, namespaceName, mclass.getName(),
							propertiesNames, opsSignature);

					final InterfaceID newIfaceID = ClientManagementLib.newInterface(ownerID, ownerCredential, newIface);
					if (newIfaceID != null) {
						System.out.println(""[LOG] Created interface for class "" + newIface.getClassName());
						final InterfaceInContract ifaceInContract = new InterfaceInContract(newIface, opImpls);
						newInterfacesInContract.add(ifaceInContract);
					}
				}

				if (newInterfacesInContract.size() <= 0) {
					Util.finishErr(""No new interfaces found, contract is not created."", ERRCODE.ERROR);
					return;
				}

				final Set<AccountID> applicantIDs = new HashSet<>();
				applicantIDs.add(benefID);
				final Calendar beginDate = Calendar.getInstance();
				final Calendar endDate = Calendar.getInstance();
				beginDate.add(Calendar.YEAR, -1);
				endDate.add(Calendar.YEAR, 1);
				final Contract newContract = new Contract(namespaceName, ownerID, applicantIDs, newInterfacesInContract,
						beginDate, endDate);
				final ContractID newContractID = ClientManagementLib.newPrivateContract(ownerID, ownerCredential,
						newContract);

				if (newContractID != null) {
					Util.finishOut(""Created contract "" + newContractID);
				} else {
					Util.finishErr(""Model contract cannot be created"", ERRCODE.WARNING);
				}
			}
		} catch (final Exception ex) {
			Util.finishErr(""Exception caught. Check your account and credentials."", ERRCODE.ERROR);
		}
		System.exit(0); // Call this to finish logging threads
	}","@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      String[] stringArray0 = new String[4];
      // Undeclared exception!
      try { 
        NewModelContract.main(stringArray0);
        fail(""Expecting exception: NoClassDefFoundError"");
      
      } catch(NoClassDefFoundError e) {
         //
         // es/bsc/dataclay/commonruntime/DataClayRuntime
         //
         verifyException(""es.bsc.dataclay.tool.NewModelContract"", e);
      }
  }",Call this to finish logging threads
,"@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      MockException mockException0 = new MockException();
      XeroNotFoundException xeroNotFoundException0 = new XeroNotFoundException((-3726), """", mockException0);
      int int0 = xeroNotFoundException0.getStatusCode();
      assertEquals(0, int0);
  }",
"@SuppressWarnings(""unchecked"")
  public static <T> T createProxy(InvocationHandler handler, Class<T> itface) {
    if (handler instanceof ObjectProxy) {
      ObjectProxy proxy = (ObjectProxy) handler;
      if (!ReflectUtils.isSubClassOrInterfaceOf(proxy.getProxiedObject().getClass(), itface)) {
        throw new IllegalArgumentException(
            proxy.getProxiedObject().getClass() + "" does not extend "" + itface);
      }
    }
    return (T) Proxy.newProxyInstance(itface.getClassLoader(),
        new Class<?>[]{itface}, handler);
  }","@Test(timeout = 4000)
  public void test0()  throws Throwable  {
      ObjectProxyBuilder objectProxyBuilder0 = new ObjectProxyBuilder();
      ObjectProxyInvocationHandler objectProxyInvocationHandler0 = ObjectProxyInvocationHandler.create((Object) objectProxyBuilder0);
      Class<Integer>[] classArray0 = (Class<Integer>[]) Array.newInstance(Class.class, 3);
      // Undeclared exception!
      try { 
        ObjectProxyBuilder.createProxy((InvocationHandler) objectProxyInvocationHandler0, (Class<?>[]) classArray0);
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""com.github.edgar615.util.reflect.ObjectProxyBuilder"", e);
      }
  }",创建一个代理对象.@param handler InvocationHandler @param itface 需要代理的接口 @return 代理对象.
,"@Test(timeout = 4000)
  public void test2()  throws Throwable  {
      ResourcePartition resourcePartition0 = new ResourcePartition((-2339), (-2339), (PartitionPredicate) null);
      int int0 = resourcePartition0.getInitialNumResources();
      assertEquals((-2339), resourcePartition0.getPartitionId());
  }",
,"@Test(timeout = 4000)
  public void test0()  throws Throwable  {
      DataSetManagerSQLStatements.SqlStatements.loadStatements();
      DataSetManagerSQLStatements.SqlStatements dataSetManagerSQLStatements_SqlStatements0 = DataSetManagerSQLStatements.SqlStatements.DELETE_DATASET;
      String string0 = dataSetManagerSQLStatements_SqlStatements0.getSqlStatement();
      assertNull(string0);
  }",
"@Override
    public double test(final Map<String, Double> target, final Map<String, Double> baseline) {
        final double[] b = new double[baseline.keySet().size()];//baseline
        final double[] t = new double[target.keySet().size()];//target
        int c = 0;
        for (final String key : baseline.keySet()) {
            b[c] = baseline.get(key).doubleValue();
            t[c] = target.get(key).doubleValue();
            c++;
        }
        final double trueDiff = Math.abs(BasicStats.mean(b) - BasicStats.mean(t));
        double pvalue = 0.0;
        final double[] pb = new double[baseline.keySet().size()];//permutation of baseline
        final double[] pt = new double[target.keySet().size()];//permutation of target
        for (int i = 0; i < nPermutation; i++) {
            final char[] bits = randomBitVector(b.length).toCharArray();
            for (int j = 0; j < b.length; j++) {
                if (bits[j] == '0') {
                    pb[j] = b[j];
                    pt[j] = t[j];
                } else {
                    pb[j] = t[j];
                    pt[j] = b[j];
                }
            }
            final double pDiff = Math.abs(BasicStats.mean(pb) - BasicStats.mean(pt));
            if (pDiff >= trueDiff) {
                pvalue += 1.0;
            }
        }
        return pvalue / nPermutation;
    }","@Test(timeout = 4000)
  public void test0()  throws Throwable  {
      RandomPermutationTest randomPermutationTest0 = new RandomPermutationTest();
      RandomPermutationTest.nPermutation = 1631;
      HashMap<String, Double> hashMap0 = new HashMap<String, Double>();
      Double double0 = new Double(1631);
      hashMap0.put("""", double0);
      double double1 = randomPermutationTest0.test(hashMap0, hashMap0);
      assertEquals(0.0, double1, 0.01);
  }","Run the randomization test @param baseline @param target @returnbaseline
target
permutation of baseline
permutation of target"
"public void transferPEs(int partId, RangeList list) {
		if (partId < 0 || partId >= rangesParts.length) {
			throw new IndexOutOfBoundsException(""Partition "" + 
					partId + "" does not exist"");
		}

		for (RangeList range : rangesParts) {
			if (range != null) {
				range.remove(list);
			}
		}
		
		if (rangesParts[partId] == null) {
			rangesParts[partId] = new RangeList();
		}
		rangesParts[partId].addAll(list.clone());
		rangesParts[partId].mergeRanges();
	}","@Test(timeout = 4000)
  public void test6()  throws Throwable  {
      PartProfileEntry partProfileEntry0 = new PartProfileEntry(1962, 1962);
      RangeList rangeList0 = new RangeList(1934, (-834));
      partProfileEntry0.transferPEs(1934, rangeList0);
      String string0 = partProfileEntry0.toString();
      assertEquals(""ProfileEntry={time=1962; gridlets=1; numPE=0; queue 1934={[]}}"", string0);
  }",Transfers PEs from partitions to one selected partition @param partId the partition receiving the ranges @param list the list of ranges
,"@Test(timeout = 4000)
  public void test2()  throws Throwable  {
      Box2D box2D0 = new Box2D();
      // Undeclared exception!
      try { 
        box2D0.toRectangle();
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""com.irurueta.geometry.Box2D"", e);
      }
  }",
"public static void copyFile(File src, File dest) throws IOException {

        if (src == null)
            throw new NullPointerException(""Source must not be null"");
        if (dest == null)
            throw new NullPointerException(""Destination must not be null"");
        if (!src.exists())
            throw new FileNotFoundException(""Source '"" + src + ""' does not exist"");
        if (!src.isFile())
            throw new IOException(""Source '"" + src + ""' is not a file"");
        if (dest.exists())
            throw new IOException(""Destination '"" + dest + ""' is already exists"");

        FileChannel in = null, out = null;
        try {
            in = new FileInputStream(src).getChannel();
            out = new FileOutputStream(dest).getChannel();

            in.transferTo(0, in.size(), out);
        } finally {
            try {
                in.close();
                out.close();
            } catch (IOException e) {
                // Ignore.
            }
        }

        if (src.length() != dest.length()) {
            throw new IOException(""Failed to copy full contents from '"" +
                src + ""' to '"" + dest + ""'"");
        }

        dest.setLastModified(src.lastModified());
    }","@Test(timeout = 4000)
  public void test16()  throws Throwable  {
      MockFile mockFile0 = new MockFile(""(#r:dRw.]"");
      File file0 = MockFile.createTempFile(""(#r:dRw.]"", ""(#r:dRw.]"", (File) mockFile0);
      file0.setReadOnly();
      MockFile mockFile1 = new MockFile(""4"");
      try { 
        FileUtil.moveFile(file0, mockFile1);
        fail(""Expecting exception: IOException"");
      
      } catch(IOException e) {
         //
         // Failed to delete the src file '/home/shaker/Desktop/mutants_io/temp_projects/casmi-casmi/14/buggy/(#r:dRw.]/(#r:dRw.]0(#r:dRw.]' after copying.
         //
         verifyException(""casmi.util.FileUtil"", e);
      }
  }","Copies a file to a new location preserving the file date.@param src An existing file to copy, must not be <code>null<code>. @param dest The new file, must not be <code>null<code> and exist.@throws IOException If copying is failed."
"public static <E> boolean isNullOrEmpty(final Collection<E> collection) {
        return collection == null || collection.isEmpty();
    }","@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      // Undeclared exception!
      try { 
        CollectionsUtil.isNullOrEmpty((Collection<Object>) null);
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
      }
  }","Checks, if the collection is null or empty. @param collection Collection to be checked. @param <E> Type of the elements in the collection. @return {@code true} if the collection is {@code null} or empty, {@code false} if it is not null and contains any data. @see Collection#isEmpty()"
"public T getResult() throws Throwable {
    latch.await();
    if (throwable != null) {
      throw throwable;
    }
    return rv;
  }","@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      Callable<Object> callable0 = (Callable<Object>) mock(Callable.class, new ViolatedAssumptionAnswer());
      doReturn("""").when(callable0).call();
      try { 
        SyncThread.getDistinctResultCount(1, callable0);
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""net.spy.memcached.compat.SyncThread"", e);
      }
  }",Get the result from the invocation.@return the result @throws Throwable if an error occurred when evaluating the callable
,"@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      MockException mockException0 = new MockException("""");
      XeroUnauthorizedException xeroUnauthorizedException0 = new XeroUnauthorizedException(552, """", mockException0);
      xeroUnauthorizedException0.getMessage();
      assertEquals(0, xeroUnauthorizedException0.getStatusCode());
  }",
"static Map<String, String> putIfNotSet(Map<String, String> target, Map<String, String> defaults) {
    boolean needsChange = defaults.keySet().stream().anyMatch(key -> !target.containsKey(key));
    if (needsChange) {
      Map<String, String> copy = new HashMap<>(target);
      for (final String key : defaults.keySet()) {
        if (!copy.containsKey(key)) {
          copy.put(key, defaults.get(key));
        }
      }
      return copy;
    }
    return target;
  }","@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      HashMap<String, String> hashMap0 = new HashMap<String, String>(0);
      Map<String, String> map0 = DefaultQueryParameter.putIfNotSet(hashMap0, hashMap0);
      hashMap0.put(""limit"", ""limit"");
      Map<String, String> map1 = DefaultQueryParameter.putIfNotSet(map0, hashMap0);
      assertFalse(map1.isEmpty());
  }","Update a given map with some default values if not already present in map.@param target the map to be filled with values, if a key for them is not set already. @param defaults the list of defaults, to be set. @return the same map if no change had to be made, a new map otherwise."
"public static int findIndex(Object[] array,Object value){
        if (array == null || value == null){
            return -1;
        }
        int i = 0;
        for (Object obj : array){
            if (obj.equals(value)){
                return i;
            }
            i++;
        }
        return -1;
    }","@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      CollectionUtil collectionUtil0 = new CollectionUtil();
      Object[] objectArray0 = new Object[2];
      objectArray0[0] = (Object) collectionUtil0;
      objectArray0[1] = (Object) collectionUtil0;
      int int0 = CollectionUtil.findIndex(objectArray0, objectArray0[1]);
      assertEquals((-1), int0);
  }","Find the index of a value inside an array. If not found, or any of the param is null, return -1 @param array The array to lookup the value (if null, return -1) @param value The value to lookup (if null, return -1) @return the index of the match value, or -1 is not found"
"public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (obj instanceof Map.Entry == false) {
            return false;
        }
        Map.Entry other = (Map.Entry) obj;
        return (getKey() == null ? other.getKey() == null : getKey().equals(
                other.getKey()))
                && (getValue() == null ? other.getValue() == null : getValue()
                        .equals(other.getValue()));
    }","@Test(timeout = 4000)
  public void test9()  throws Throwable  {
      Integer integer0 = new Integer(1);
      DefaultMapEntry<Object, Integer> defaultMapEntry0 = new DefaultMapEntry<Object, Integer>(integer0, integer0);
      // Undeclared exception!
      try { 
        defaultMapEntry0.equals(integer0);
        fail(""Expecting exception: ClassCastException"");
      
      } catch(ClassCastException e) {
         //
         // java.lang.Integer cannot be cast to java.util.Map$Entry
         //
         verifyException(""org.jivesoftware.smack.util.collections.AbstractMapEntry"", e);
      }
  }",Compares this Map Entry with another Map Entry. <p> Implemented per API documentation of {@link java.util.Map.Entry#equals(Object)} @param obj the object to compare to @return true if equal key and value
"public static String bytesToHexString(byte[] bytes) {
        StringBuffer sb = new StringBuffer(bytes.length);
        String sTmp;

        for (int i = 0; i < bytes.length; i++) {
            sTmp = Integer.toHexString(0xFF & bytes[i]);
            if (sTmp.length() < 2)
                sb.append(0);
            sb.append(sTmp.toUpperCase());
        }

        return sb.toString();
    }","@Test(timeout = 4000)
  public void test2()  throws Throwable  {
      byte[] byteArray0 = new byte[2];
      byteArray0[0] = (byte) (-43);
      String string0 = HexUtils.bytesToHexString(byteArray0);
      assertEquals(""D50"", string0);
  }",字节数组转16进制@param bytes 需要转换的byte数组 @return 转换后的Hex字符串
"public static void getClasses(final String actualSrcDir,
			final File srcDirectory, final Set<String> classNames, final String extension,
			final Set<String> packagesToExclude) {

		if (srcDirectory.isDirectory()) {
			final File[] files = srcDirectory.listFiles();
			if (files.length > 0) {
				for (final File file : files) {
					if (file.isDirectory()) {
						// Loop through its listFiles() recursively.
						getClasses(actualSrcDir, file, classNames, extension, packagesToExclude);
					} else {
						final String name = file.getName();
						if (name.endsWith(extension)) {
							String fullName = file.getPath();
							fullName = fullName.replace(actualSrcDir, """");
							fullName = fullName.replace(extension, """");
							// Remove starting bar ""/"" so we can later replace all bars for '.' as packages
							fullName = fullName.replace(File.separator, ""."");
							if (fullName.startsWith(""."")) {
								fullName = fullName.substring(1);
							}

							boolean addClass = true;
							if (packagesToExclude != null) {
								for (final String packageToExclude : packagesToExclude) {
									if (fullName.contains(packageToExclude)) {
										addClass = false;
										break;
									}
								}
							}
							if (addClass) {
								classNames.add(fullName);
							}
						}

					}
				}
			}
		}
	}","@Test(timeout = 4000)
  public void test4()  throws Throwable  {
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile("".class"");
      byte[] byteArray0 = new byte[4];
      FileSystemHandling.appendDataToFile(evoSuiteFile0, byteArray0);
      // Undeclared exception!
      try { 
        StubClassLoader.getStubInfosFromClassPath("""");
        fail(""Expecting exception: NoClassDefFoundError"");
      
      } catch(NoClassDefFoundError e) {
         //
         // org/yaml/snakeyaml/representer/Representer
         //
         verifyException(""es.bsc.dataclay.util.management.stubs.StubClassLoader"", e);
      }
  }",Get class names except ones in package provided @param actualSrcDir Actual directory @param srcDirectory directories @param classNames [out] File names @param extension Extension of classes to check @param packagesToExclude Packages to exclude
"public byte[] zip(String str) {
        GZIPOutputStream zipStream = null;
        try {
            ByteArrayOutputStream targetStream = new ByteArrayOutputStream();
            zipStream = new GZIPOutputStream(targetStream);
            zipStream.write(str.getBytes());
            zipStream.close();
            byte[] zipped = targetStream.toByteArray();
            targetStream.close();
            return zipped;
        } catch (IOException ex) {
            throw new RuntimeException(ex);
        } finally {
            try {
                if (zipStream != null) {
                    zipStream.close();
                }
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        }
    }","@Test(timeout = 4000)
  public void test0()  throws Throwable  {
      Zipper zipper0 = new Zipper();
      // Undeclared exception!
      try { 
        zipper0.zip(""r3^R_f{nxoq<K/_bX-T"");
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""me.moocar.logbackgelf.Zipper"", e);
      }
  }",zips up a string into a GZIP format.@param str The string to zip @return The zipped string
,"@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      MetaDataServiceSQLStatements.SqlStatements metaDataServiceSQLStatements_SqlStatements0 = MetaDataServiceSQLStatements.SqlStatements.UPDATE_DATASETID_METADATA;
      metaDataServiceSQLStatements_SqlStatements0.getSqlStatement();
      String string0 = metaDataServiceSQLStatements_SqlStatements0.getSqlStatement();
      assertNull(string0);
  }",
"public static Account parseAdminUser() {
		final String userName = ProcessEnvironment.getInstance().get(""DATACLAY_ADMIN_USER"");
		final String userPassword = ProcessEnvironment.getInstance().get(""DATACLAY_ADMIN_PASSWORD"");

		if (userName != null && !userName.isEmpty() && userPassword != null && !userPassword.isEmpty()) {
			final Account adminAccount = new Account(userName,
					AccountRole.ADMIN_ROLE, new PasswordCredential(userPassword));
			return adminAccount;
		} else {
			return null;
		}
	}","@Test(timeout = 4000)
  public void test0()  throws Throwable  {
      // Undeclared exception!
      try { 
        CfgAdminEnvLoader.parseAdminUser();
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
      }
  }",Parse account admin user @return Account admin
,"@Test(timeout = 4000)
  public void test2()  throws Throwable  {
      NotificationMgrSQLStatements.SqlStatements notificationMgrSQLStatements_SqlStatements0 = NotificationMgrSQLStatements.SqlStatements.DROP_TABLE_EVENT_LISTENERS;
      String string0 = notificationMgrSQLStatements_SqlStatements0.getSqlStatement();
      assertNull(string0);
  }",
,"@Test(timeout = 4000)
  public void test0()  throws Throwable  {
      DataContractManagerSQLStatements.SqlStatements dataContractManagerSQLStatements_SqlStatements0 = DataContractManagerSQLStatements.SqlStatements.DELETE_DATACONTRACT;
      String string0 = dataContractManagerSQLStatements_SqlStatements0.getSqlStatement();
      assertNull(string0);
  }",
"public static Renderer getRenderer(String type)
	{
		String classname = (String)RENDERERS_CLASSNAMES.get(type.toLowerCase());
		if (null == classname)
		{
			return null;
		}
		
		try
		{
			Class klass = Class.forName(classname);
			return (Renderer)klass.newInstance();
		}
		catch (Exception e)
		{
			throw new RuntimeException(e);
		}
	}","@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      // Undeclared exception!
      try { 
        XhtmlRendererFactory.getRenderer(""c++"");
        fail(""Expecting exception: NoClassDefFoundError"");
      
      } catch(NoClassDefFoundError e) {
      }
  }","Instantiates an instance of a known <code>XhtmlRenderer<code> according to the type that's provided.@param type The type of renderer, look at the static variables of this class to see which ones are supported. @return an instance of the <code>XhtmlRenderer<code> that corresponds to the type; or <p><code>null<code> if the type wasn't known @since 1.0"
"public static String nanosToText(final long nanos) {
        if (nanos < 0) {
            throw new IllegalArgumentException(""Non negative value expected, but "" + nanos + "" found."");
        }

        long time = nanos;
        boolean wasZero = true;
        final StringBuilder output = new StringBuilder();
        final long nanosOnly = time % 1000;
        if (nanosOnly != 0 || time == 0) {
            output.append(nanosOnly);
            output.append("" Nanosekunde"" + (nanosOnly == 1 ? """" : ""n""));
            wasZero = false;
        }
        time /= 1000;
        final long micro = time % 1000;
        if (time > 0 && (micro > 0 || !wasZero)) {
            output.insert(0, micro + "" Mikrosekunde"" + (micro == 1 ? """" : ""n"") + (wasZero ? """" : "", ""));
            wasZero = false;
        }
        time /= 1000;
        final long millis = time % 1000;
        if (time > 0 && (millis > 0 || !wasZero)) {
            output.insert(0, millis + "" Millisekunde"" + (millis == 1 ? """" : ""n"") + (wasZero ? """" : "", ""));
            wasZero = false;
        }
        time /= 1000;
        final long secs = time % 60;
        if (time > 0 && (secs > 0 || !wasZero)) {
            output.insert(0, secs + "" Sekunde"" + (secs == 1 ? """" : ""n"") + (wasZero ? """" : "", ""));
            wasZero = false;
        }
        time /= 60;
        final long minutes = time % 60;
        if (time > 0 && (minutes > 0 || !wasZero)) {
            output.insert(0, minutes + "" Minute"" + (minutes == 1 ? """" : ""n"") + (wasZero ? """" : "", ""));
            wasZero = false;
        }
        time /= 60;
        final long hours = time % 24;
        if (time > 0 && (hours > 0 || !wasZero)) {
            output.insert(0, hours + "" Stunde"" + (hours == 1 ? """" : ""n"") + (wasZero ? """" : "", ""));
            wasZero = false;
        }
        time /= 24;
        if (time > 0) {
            output.insert(0, time + "" Tag"" + (time == 1 ? """" : ""e"") + (wasZero ? """" : "", ""));
        }
        return output.toString();
    }","@Test(timeout = 4000)
  public void test2()  throws Throwable  {
      String string0 = TimeFormatterHelper.nanosToText(5410L);
      assertEquals(""5 Millisekunden, 410 Mikrosekunden, 410 Nanosekunden"", string0);
  }","Erstellt eine ausformulierte Zeitspanne auf Basis von Nanosekunden. Kann z.B. bei der Ausgabe von Laufzeiten in Log-Nachrichten verwendet werden. Eine Ausgabe hat z.B. die Form ""1 Tag, 0 Stunden, 4 Minuten, 12 Sekunden, 134 Millisekunden, 423 Mikrosekunden, 1 Nanosekunde"" oder ""1 Minute, 12 Sekunden"". @param nanos Zeitspanne in Nanosekunden. @return Textuelle Repräsentation der Zeitspanne. @see System#nanoTime()"
"public static String decode(byte[] bytes) {
        char[] digits = new char[bytes.length * 2];
        int charPos = digits.length - 1;// LSB

        for (int bytePos = bytes.length - 1; bytePos >= 0; bytePos--) {
            digits[charPos--] = (char) ((bytes[bytePos] & 0x0f) + 48);
            digits[charPos--] = (char) (((bytes[bytePos] & 0xf0) >> 4) + 48);
        }
        return new String(digits);
    }","@Test(timeout = 4000)
  public void test2()  throws Throwable  {
      byte[] byteArray0 = new byte[7];
      String string0 = Bcd.decode(byteArray0);
      assertEquals(""?0?0?0?0?0?0?0"", string0);
  }",@param bytes @return the decoded BCD digits as StringLSB
"@Override
    public double evaluate(double accelerometerMse, double gyroscopeMse,
                           double magnetometerMse) {
        return accelerometerMse + gyroscopeMse + magnetometerMse;
    }","@Test(timeout = 4000)
  public void test0()  throws Throwable  {
      DefaultAccelerometerGyroscopeAndMagnetometerMseRule defaultAccelerometerGyroscopeAndMagnetometerMseRule0 = new DefaultAccelerometerGyroscopeAndMagnetometerMseRule();
      double double0 = defaultAccelerometerGyroscopeAndMagnetometerMseRule0.evaluate((-2231.183592207725), (-2231.183592207725), 67.392);
      assertEquals(67.392, double0, 0.01);
  }","Evaluates provided accelerometer calibration MSE, gyroscope calibration MSE and magnetometer calibration MSE in order to obtain a single MSE value representing all three of them.@param accelerometerMse accelerometer calibration MSE. @param gyroscopeMse gyroscope calibration MSE. @param magnetometerMse magnetometer calibration MSE. @return single MSE value."
"public static String generateHash(String pwd) {
		String encryptedPwd=""00000000"";
		String password = pwd;
		
		// if there is no password or the length is 0, then skip this and return ""00000000"" as default
		// otherwise process the password
		if(password != null && password.length() > 0) {
			// Truncate the password to 15 characters.
			if(password.length() > 15) {
				password = password.substring(0,15);
			}

			// compute key's high-order word
			// initialize to table value
			int hi = initialCodeArray[password.length()-1];
			
			int idxF = 0;	// forward index
			int idxR = password.length()-1; // reverse index
			// process each character left to right.
			// check each bit and if it is set, xor the hi word with 
			// the table entry for the position in password and bit position.
			for(; idxF<password.length(); idxF++,idxR--) {
				int ch = password.charAt(idxF);
				if((ch & 0x0001)!= 0) {
					hi ^= encryptionMatrix[idxR][0];
				}
				if((ch & 0x0002)!= 0) {
					hi ^= encryptionMatrix[idxR][1];
				}
				if((ch & 0x0004)!= 0) {
					hi ^= encryptionMatrix[idxR][2];
				}
				if((ch & 0x0008)!= 0) {
					hi ^= encryptionMatrix[idxR][3];
				}
				if((ch & 0x0010)!= 0) {
					hi ^= encryptionMatrix[idxR][4];
				}
				if((ch & 0x0020)!= 0) {
					hi ^= encryptionMatrix[idxR][5];
				}
				if((ch & 0x0040)!= 0) {
					hi ^= encryptionMatrix[idxR][6];
				}
			}
			// Compute Key's low-order word
			idxF = password.length()-1;
			int lo = 0;
			// low order word is computed in reverse.
			for(;idxF>= 0; idxF--) {
				int ch = password.charAt(idxF);
				lo = (((lo >> 14) & 0x001) | (( lo << 1) & 0x7fff)) ^ ch;
			}
			// finally incorporate the password length into the low word and use value from formula
			lo = (((lo >> 14) & 0x001) | (( lo << 1) & 0x7fff)) ^ password.length() ^ 0xCE4B;
			
			// correct for little-endian - 
			// Java always uses big-endian. According to tests - RTF wants little-endian but is not documented
			encryptedPwd = Integer.toHexString(lo).substring(2,4) + Integer.toHexString(lo).substring(0,2);
			encryptedPwd += Integer.toHexString(hi).substring(2,4) + Integer.toHexString(hi).substring(0,2);
		}
		return encryptedPwd;
	}","@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      String string0 = RtfProtection.generateHash(""s<x!=ElSF.2Xo"");
      assertEquals(""73f8d1a6"", string0);
  }","<code>generateHash<code> generates the password hash from a clear text string. @param pwd Clear text string input @return hex encoded password hash @since 2.1.1if there is no password or the length is 0, then skip this and return ""00000000"" as default
otherwise process the password"
"public static String getParent( String path )
    {
        int i = path.lastIndexOf( FILE_SEPARATOR );

        if ( i == -1 )
        {
            return null;
        }

        return path.substring( 0, i );
    }","@Test(timeout = 4000)
  public void test2()  throws Throwable  {
      // Undeclared exception!
      try { 
        PathUtils.getParent("""");
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
      
      } catch(StringIndexOutOfBoundsException e) {
      }
  }",Gets the parent path of the given UNIX path. @param path the path. @return the parent path.
"public static final String toASCII(String in) {
        try {
            return IDN.toASCII(in);
        } catch (Exception e) {
            // let's continue with the character by character encoding hack.
        }
        final StringBuilder sb = new StringBuilder();
        for (int i=0;i<in.length();i++) {
            try {
                sb.append(IDN.toASCII(in.substring(i, i + 1)));
            }
            catch (Exception e) {}
        }
        if (sb.length() == 0) {
            throw new RuntimeException(""Unable to convert "" + in + "" to ASCII"");
        }
        return sb.toString();
    }","@Test(timeout = 4000)
  public void test0()  throws Throwable  {
      // Undeclared exception!
      try { 
        FakerIDN.toASCII("""");
        fail(""Expecting exception: RuntimeException"");
      
      } catch(RuntimeException e) {
         //
         // Unable to convert  to ASCII
         //
         verifyException(""com.github.javafaker.service.FakerIDN"", e);
      }
  }",{@link IDN#toASCII(String)} is too picky for our needs. It was throwing exceptions for fa.yml and he.yml as they're Bidi languages and something was causing them to die. This is kind of a brute force fix but it appears to fix the issue. @param in input @return ascii
,"@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      AccountMgrSQLStatements.SqlStatements accountMgrSQLStatements_SqlStatements0 = AccountMgrSQLStatements.SqlStatements.EXISTS_ACCOUNT_BY_ID;
      AccountMgrSQLStatements.SqlStatements.loadStatements();
      String string0 = accountMgrSQLStatements_SqlStatements0.getSqlStatement();
      assertNull(string0);
  }",
,"@Test(timeout = 4000)
  public void test0()  throws Throwable  {
      ClassManagerSQLStatements.SqlStatements classManagerSQLStatements_SqlStatements0 = ClassManagerSQLStatements.SqlStatements.DELETE_PROPERTY_BY_ID;
      String string0 = classManagerSQLStatements_SqlStatements0.getSqlStatement();
      assertNull(string0);
  }",
,"@Test(timeout = 4000)
  public void test0()  throws Throwable  {
      LinkedList<CDARichMark> linkedList0 = new LinkedList<CDARichMark>();
      CDARichText cDARichText0 = new CDARichText((CharSequence) null, linkedList0);
      CharSequence charSequence0 = cDARichText0.getText();
      assertNull(charSequence0);
  }",
"protected T calculate(FormulaEvaluatorConfiguration conf, T v1, T v2) {
    switch (conf.getDefaultNullHandling()) {
      case NULL:
        return v1 == null || v2 == null ? null : calculateDefault(conf, v1, v2);
      case ZERO:
        return calculateDefault(conf, v1 == null ? zero() : v1, v2 == null ? zero() : v2);
      default:
        if (v1 == null || v2 == null) {
          throw new FormulaEvaluatorNullArgumentException(this.getOperatorName(), asList(v1, v2));
        }
        return calculateDefault(conf, v1, v2);
    }
  }","@Test(timeout = 4000)
  public void test5()  throws Throwable  {
      Double double0 = new Double((-627.446132564));
      ConstantTerm<Double> constantTerm0 = new ConstantTerm<Double>(double0);
      DoubleModuloOperator doubleModuloOperator0 = new DoubleModuloOperator(constantTerm0, constantTerm0);
      FormulaEvaluatorConfiguration formulaEvaluatorConfiguration0 = new FormulaEvaluatorConfiguration();
      FormulaEvaluatorConfiguration.DefaultNullHandling formulaEvaluatorConfiguration_DefaultNullHandling0 = FormulaEvaluatorConfiguration.DefaultNullHandling.NULL;
      formulaEvaluatorConfiguration0.setDefaultNullHandling(formulaEvaluatorConfiguration_DefaultNullHandling0);
      Double double1 = doubleModuloOperator0.evaluate((VariableValueProvider<Double>) null, formulaEvaluatorConfiguration0);
      assertNull(double1);
  }",Implementation for this operator.@param conf the configuration. @param v1 Operand 1. @param v2 Operand 2. @return The result of the operation.
"public static String fromByte(byte model) {
        if (Arrays.asList(UNSUPPORTED_MAKE).contains(model)) {
            return UnsupportedDevice;
        }

        if (Arrays.asList(INVALID_MAKES).contains(model)) {
            return InvalidDevice;
        }
        if (model < MAKE_NAME_LOOKUP_TABLE.length) {
            return MAKE_NAME_LOOKUP_TABLE[model];
        }

        return UnknownDevice;
    }","@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      String string0 = AcceptorModel.fromByte((byte)3);
      assertEquals(""Unsupported Device"", string0);
  }",Retrieve model name from lookup table using standard acctype code@param model byte @return String
"@Override
    public double evaluate(double accelerometerMse, double gyroscopeMse) {
        return accelerometerMse + gyroscopeMse;
    }","@Test(timeout = 4000)
  public void test0()  throws Throwable  {
      DefaultAccelerometerAndGyroscopeMseRule defaultAccelerometerAndGyroscopeMseRule0 = new DefaultAccelerometerAndGyroscopeMseRule();
      double double0 = defaultAccelerometerAndGyroscopeMseRule0.evaluate(0.0, 0.0);
      assertEquals(Double.NaN, double0, 0.01);
  }",Evaluates provided accelerometer calibration MSE and gyroscope calibration MSE in order to obtain a single MSE value representing both.@param accelerometerMse accelerometer calibration MSE. @param gyroscopeMse gyroscope calibration MSE. @return single MSE value.
,"@Test(timeout = 4000)
  public void test0()  throws Throwable  {
      SessionManagerSQLStatements.SqlStatements sessionManagerSQLStatements_SqlStatements0 = SessionManagerSQLStatements.SqlStatements.SELECT_EXT_SESSION;
      sessionManagerSQLStatements_SqlStatements0.getSqlStatement();
      String string0 = sessionManagerSQLStatements_SqlStatements0.getSqlStatement();
      assertNull(string0);
  }",
,"@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      InterfaceManagerSQLStatements.SqlStatements interfaceManagerSQLStatements_SqlStatements0 = InterfaceManagerSQLStatements.SqlStatements.DELETE_INTERFACE;
      InterfaceManagerSQLStatements.SqlStatements.loadStatements();
      String string0 = interfaceManagerSQLStatements_SqlStatements0.getSqlStatement();
      assertNull(string0);
  }",
,"@Test(timeout = 4000)
  public void test3()  throws Throwable  {
      ContractManagerSQLStatements.SqlStatements contractManagerSQLStatements_SqlStatements0 = ContractManagerSQLStatements.SqlStatements.SELECT_IFACEINCONTRACT;
      String string0 = contractManagerSQLStatements_SqlStatements0.getSqlStatement();
      assertNull(string0);
  }",
"public static Method getFirstMethod(Class cls, String methodName){
       for (Method m : cls.getMethods()){
           if (m.getName().equals(methodName)){
               return m;
           }
       }
       return null;
    }","@Test(timeout = 4000)
  public void test0()  throws Throwable  {
      Class<Object> class0 = Object.class;
      Method method0 = ClassUtil.getFirstMethod(class0, ""equals"");
      assertNull(method0);
  }",Convenient getter that get the first method with this given name (disregard arguments). Should be use in testing only code. @param cls @param methodName @return
,"@Test(timeout = 4000)
  public void test0()  throws Throwable  {
      NodeDistance nodeDistance0 = new NodeDistance((TreeNode) null, (TreeNode) null, 1077.259);
      assertEquals(0.0, nodeDistance0.distance, 0.01);
  }",
"public static boolean containsIgnoreCase(String[] array, String value) {
    for (String str : array) {
      if (value == null && str == null) {
        return true;
      }
      if (value != null && value.equalsIgnoreCase(str)) {
        return true;
      }
    }
    return false;
  }","@Test(timeout = 4000)
  public void test3()  throws Throwable  {
      String[] stringArray0 = new String[3];
      String[] stringArray1 = new String[5];
      stringArray1[0] = """";
      // Undeclared exception!
      try { 
        StringUtil.containsIgnoreCase(stringArray1, stringArray0[0]);
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
      }
  }",Check if the given array contains the given value (with case-insensitive comparison).@param array The array @param value The value to search @return true if the array contains the value
"static public long calculateChecksum(byte[] buf) {
    int length = buf.length;
    int i = 0;

    long sum = 0;
    long data;

    // Handle all pairs
    while (length > 1) {
      // Corrected to include @Andy's edits and various comments on Stack Overflow
      data = (((buf[i] << 8) & 0xFF00) | ((buf[i + 1]) & 0xFF));
      sum += data;
      // 1's complement carry bit correction in 16-bits (detecting sign extension)
      if ((sum & 0xFFFF0000) > 0) {
        sum = sum & 0xFFFF;
        sum += 1;
      }

      i += 2;
      length -= 2;
    }

    // Handle remaining byte in odd length buffers
    if (length > 0) {
      // Corrected to include @Andy's edits and various comments on Stack Overflow
      sum += (buf[i] << 8 & 0xFF00);
      // 1's complement carry bit correction in 16-bits (detecting sign extension)
      if ((sum & 0xFFFF0000) > 0) {
        sum = sum & 0xFFFF;
        sum += 1;
      }
    }

    // Final 1's complement value correction to 16-bits
    sum = ~sum;
    sum = sum & 0xFFFF;
    return sum;

  }","@Test(timeout = 4000)
  public void test0()  throws Throwable  {
      byte[] byteArray0 = new byte[7];
      byteArray0[4] = (byte) (-79);
      byteArray0[6] = (byte) (-122);
      long long0 = Checksum.calculateChecksum(byteArray0);
      assertEquals(14079L, long0);
  }","http:stackoverflow.comquestions4113890how-to-calculate-the-internet-checksum-from-a-byte-in-javaHandle all pairs
Handle remaining byte in odd length buffers
Final 1's complement value correction to 16-bits"
,"@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      LogicMetadataSQLStatements.SqlStatements logicMetadataSQLStatements_SqlStatements0 = LogicMetadataSQLStatements.SqlStatements.EXISTS_STORAGE_LOCATION_BY_HOSTPORT;
      logicMetadataSQLStatements_SqlStatements0.getSqlStatement();
      String string0 = logicMetadataSQLStatements_SqlStatements0.getSqlStatement();
      assertNull(string0);
  }",
"public static void main(final String[] args) throws Exception {
		if (args.length != 2) {
			Util.finishErr(
					""Bad arguments. Usage: \n\n "" + GetNamespaces.class.getSimpleName() + "" <user_name> <user_pass> \n"",
					ERRCODE.ERROR);
			return;
		}
		try {
			Util.init();

			final String applicantName = args[0];
			final String applicantPass = args[1];

			// Check account
			final AccountID accountID = ClientManagementLib.getAccountID(applicantName);
			if (accountID == null) {
				Util.finishErr(""Invalid account"", ERRCODE.ERROR);
				return;
			}
			final PasswordCredential credential = new PasswordCredential(applicantPass);

			// Get available public namespaces
			final Set<String> namespaces = ClientManagementLib.getNamespaces(accountID, credential);
			String msg = ""Available namespaces:\n"";
			for (final String namespace : namespaces) {
				msg += namespace + ""\n"";
			}

			Util.finishOut(msg);
		} catch (final Exception ex) {
			Util.finishErr(""Exception caught. Check your account and credentials."", ERRCODE.ERROR);
		}
		System.exit(0); // Call this to finish logging threads
	}","@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      String[] stringArray0 = new String[2];
      // Undeclared exception!
      try { 
        GetNamespaces.main(stringArray0);
        fail(""Expecting exception: NoClassDefFoundError"");
      
      } catch(NoClassDefFoundError e) {
         //
         // es/bsc/dataclay/commonruntime/DataClayRuntime
         //
         verifyException(""es.bsc.dataclay.tool.GetNamespaces"", e);
      }
  }",Call this to finish logging threads
"public CMAField setName(String name) {
    this.name = name;
    return this;
  }","@Test(timeout = 4000)
  public void test03()  throws Throwable  {
      CMAField cMAField0 = new CMAField();
      CMAField cMAField1 = cMAField0.setName("""");
      assertNull(cMAField1.getName());
  }",Sets the name for this field.@param name the name to be set @return this {@code CMAField} instance
,"@Test(timeout = 4000)
  public void test23()  throws Throwable  {
      ReferenceMap<Object, DataInputStream> referenceMap0 = new ReferenceMap<Object, DataInputStream>();
      AbstractReferenceMap.ReferenceEntrySet<Object, DataInputStream> abstractReferenceMap_ReferenceEntrySet0 = new AbstractReferenceMap.ReferenceEntrySet<Object, DataInputStream>(referenceMap0);
      // Undeclared exception!
      try { 
        abstractReferenceMap_ReferenceEntrySet0.toArray();
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.jivesoftware.smack.util.collections.AbstractReferenceMap$ReferenceIteratorBase"", e);
      }
  }",
"private static double getAngleBetweenOrientations(
            final double[] orientation1, final double[] orientation2) {
        if (orientation1.length != INHOM_COORDS ||
                orientation2.length != INHOM_COORDS) {
            throw new IllegalArgumentException();
        }

        final double x1 = orientation1[0];
        final double y1 = orientation1[1];
        final double z1 = orientation1[2];

        final double x2 = orientation2[0];
        final double y2 = orientation2[1];
        final double z2 = orientation2[2];

        final double norm1 = Math.sqrt(x1 * x1 + y1 * y1 + z1 * z1);
        final double norm2 = Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);

        final double dotProduct = (x1 * x2 + y1 * y2 + z1 * z2) / (norm1 * norm2);

        return Math.acos(dotProduct);
    }","@Test(timeout = 4000)
  public void test00()  throws Throwable  {
      InhomogeneousPoint3D inhomogeneousPoint3D0 = new InhomogeneousPoint3D();
      HomogeneousPoint3D homogeneousPoint3D0 = new HomogeneousPoint3D((-1.0), 4, (-1468.5), (-1850.050979));
      InhomogeneousPoint3D inhomogeneousPoint3D1 = homogeneousPoint3D0.toInhomogeneous();
      Triangle3D triangle3D0 = new Triangle3D(inhomogeneousPoint3D1, inhomogeneousPoint3D0, homogeneousPoint3D0);
      List<Point3D> list0 = triangle3D0.getVertices();
      homogeneousPoint3D0.setInhomZ(0.0);
      double double0 = Polygon3D.getAngleBetweenPolygons(list0, list0);
      assertEquals(1.51540468358567, double0, 0.01);
  }","Internal method to compute polygon orientation from their respective orientation vectors. Orientation vectors are provided as arrays and can be obtained by calling orientation(Polygon3D, double[]) among other methods.@param orientation1 Orientation of 1st polygon. @param orientation2 Orientation of 2nd polygon. @return Angle between two polygons in radians. @throws IllegalArgumentException Raised if any of the orientation arrays do not have length 3."
,"@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      ExecutionEnvironmentID executionEnvironmentID0 = new ExecutionEnvironmentID(""O-t{^@"");
      StorageLocationID storageLocationID0 = new StorageLocationID(executionEnvironmentID0.id);
      ExecutionEnvironmentPersistentInfo executionEnvironmentPersistentInfo0 = new ExecutionEnvironmentPersistentInfo(executionEnvironmentID0, storageLocationID0);
      StorageLocationID storageLocationID1 = executionEnvironmentPersistentInfo0.getStorageLocationID();
      assertNull(storageLocationID1);
  }",
"public void center(final Point3D result) {
        center(mVertex1, mVertex2, mVertex3, result);
    }","@Test(timeout = 4000)
  public void test27()  throws Throwable  {
      InhomogeneousPoint3D inhomogeneousPoint3D0 = new InhomogeneousPoint3D();
      Triangle3D triangle3D0 = new Triangle3D(inhomogeneousPoint3D0, inhomogeneousPoint3D0, inhomogeneousPoint3D0);
      // Undeclared exception!
      try { 
        triangle3D0.closestPoint((Point3D) inhomogeneousPoint3D0, (Point3D) inhomogeneousPoint3D0);
        fail(""Expecting exception: NoClassDefFoundError"");
      
      } catch(NoClassDefFoundError e) {
         //
         // com/irurueta/algebra/AlgebraException
         //
         verifyException(""com.irurueta.geometry.Triangle3D"", e);
      }
  }",Computes the center of this triangle and stores the result in provided point. The center of this triangle is computed as the average of its vertices.@param result Point instance where center will be stored.
"public static boolean isAtBottomSide(
            final double x, final double y, final double left,
            final double top, final double right, final double bottom, final double threshold) {
        final double bottom2 = Math.min(top, bottom);
        final double left2 = Math.min(left, right);
        final double right2 = Math.max(left, right);

        return y < (bottom2 + threshold) && x >= (left2 + threshold) &&
                x <= (right2 - threshold);
    }","@Test(timeout = 4000)
  public void test073()  throws Throwable  {
      Rectangle rectangle0 = new Rectangle();
      double double0 = rectangle0.getDistance(1.0, 1.0);
      assertEquals(1.5, double0, 0.01);
  }","Indicates if provided point coordinates are located at bottom side of rectangle defined by provided top-left and bottom-right corners up to a certain threshold. A positive threshold moves bottom border upwards, a negative threshold moves bottom border downwards@param x x coordinate of point to be checked. @param y y coordinate of point to be checked. @param left left coordinate of rectangle. @param top top coordinate of rectangle. @param right right coordinate of rectangle. @param bottom bottom coordinate of rectangle. @param threshold threshold to use as a margin to determine whether point lies at bottom side or not. @return true if point is at bottom side, false otherwise."
"@SuppressWarnings( ""unchecked"" )
    public static <K, T> List<K> createList( List<T> list, String valueMethod )
    {
        List<K> valueList = new ArrayList<>( list.size() );

        if ( list.isEmpty() )
        {
            return valueList;
        }

        Class<?> elementClass = list.iterator().next().getClass();

        Method getValueMethod;

        try
        {
            getValueMethod = elementClass.getMethod( valueMethod, new Class[0] );
        }
        catch ( Exception e )
        {
            throw new RuntimeException( ""Failed to get key method"", e );
        }

        for ( T element : list )
        {
            K value;

            try
            {
                value = (K) getValueMethod.invoke( element, (Object[]) null );
            }
            catch ( Exception e )
            {
                throw new RuntimeException( ""Failed to get key"", e );
            }

            valueList.add( value );
        }

        return valueList;
    }","@Test(timeout = 4000)
  public void test07()  throws Throwable  {
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add(""ZgtA],]!"");
      Predicate<String> predicate0 = (Predicate<String>) mock(Predicate.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(predicate0).evaluate(anyString());
      CollectionUtils.filter((Collection<String>) linkedList0, predicate0);
      assertEquals(1, linkedList0.size());
  }","Creates a list of values extracted from the provided list using the specified value method, keeping the order of the provided list.@param list the List. @param valueMethod the name of the method to obtain the value. @param <K> key type. @param <T> value type. @return an ordered List of the obtained values."
,"@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      DataSetManagerSQLStatements.SqlStatements dataSetManagerSQLStatements_SqlStatements0 = DataSetManagerSQLStatements.SqlStatements.CREATE_TABLE_DATASET;
      DataSetManagerSQLStatements.SqlStatements.loadStatements();
      String string0 = dataSetManagerSQLStatements_SqlStatements0.getSqlStatement();
      assertNull(string0);
  }",
"private JTextField createSaturationField() {
        saturationField = new JTextField(3);
        saturationField.getDocument().addDocumentListener(
                new SimpleDocumentListener(docEvent -> documentUpdated(docEvent, Field.SATURATION)));
        saturationField.setInputVerifier(inputVerifier255);
        return saturationField;
    }","@Test(timeout = 4000)
  public void test3()  throws Throwable  {
      ColorChooserPanel colorChooserPanel0 = null;
      try {
        colorChooserPanel0 = new ColorChooserPanel();
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""de.chrlembeck.util.swing.components.ColorChooserPanel"", e);
      }
  }",Erstellt und konfiguriert das Eingabefeld für den HSV-Farbsättigungswert der Farbe. @return Fertig konfiguriertes Eingabefeld.
,"@Test(timeout = 4000)
  public void test2()  throws Throwable  {
      CDAEntry cDAEntry0 = new CDAEntry();
      HashMap<String, Object> hashMap0 = new HashMap<String, Object>();
      cDAEntry0.fields = (Map<String, Object>) hashMap0;
      hashMap0.put("""", cDAEntry0.fields);
      // Undeclared exception!
      try { 
        cDAEntry0.getField("""");
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""com.contentful.java.cda.LocalizedResource$Localizer"", e);
      }
  }",
"public long getNumberFreeUnits(long startTime, long endTime) {
		Collection<ProfileEntry> avail = profile.getAvailability(startTime, endTime);
		long units = 0;
		Iterator<ProfileEntry> it = avail.iterator();
		ProfileEntry prev = it.next();
		
		while (it.hasNext()) {
			ProfileEntry curr = it.next();
			
			if (curr.getTime() < startTime) {
				prev = curr;
				continue;
			}
			
			if (curr.getTime() > endTime) {
				break;
			}
			
			units += (curr.getTime() - prev.getTime()) * prev.getNumResources();
			prev = curr;
		}
		
		units += (endTime - Math.min(endTime, prev.getTime())) * prev.getNumResources();
		return units;
	}","@Test(timeout = 4000)
  public void test0()  throws Throwable  {
      DefaultResourcePool defaultResourcePool0 = null;
      try {
        defaultResourcePool0 = new DefaultResourcePool(540);
        fail(""Expecting exception: NoClassDefFoundError"");
      
      } catch(NoClassDefFoundError e) {
         //
         // com/google/common/base/Preconditions
         //
         verifyException(""me.marcosassuncao.servsim.SimEntity"", e);
      }
  }",Returns the number of simulation units over which resources have been free. This is useful for computing resource utilisation. @param startTime start time to consider when computing the units @param endTime end time to consider when computing the units @return the number of free resource units
"public static void getClasses(final String actualSrcDir,
			final File srcDirectory, final Set<String> classNames, final String extension,
			final Set<String> packagesToExclude) {

		if (srcDirectory.isDirectory()) {
			final File[] files = srcDirectory.listFiles();
			if (files.length > 0) {
				for (final File file : files) {
					if (file.isDirectory()) {
						// Loop through its listFiles() recursively.
						getClasses(actualSrcDir, file, classNames, extension, packagesToExclude);
					} else {
						final String name = file.getName();
						if (name.endsWith(extension)) {
							String fullName = file.getPath();
							fullName = fullName.replace(actualSrcDir, """");
							fullName = fullName.replace(extension, """");
							// Remove starting bar ""/"" so we can later replace all bars for '.' as packages
							fullName = fullName.replace(File.separator, ""."");
							if (fullName.startsWith(""."")) {
								fullName = fullName.substring(1);
							}

							boolean addClass = true;
							if (packagesToExclude != null) {
								for (final String packageToExclude : packagesToExclude) {
									if (fullName.contains(packageToExclude)) {
										addClass = false;
										break;
									}
								}
							}
							if (addClass) {
								classNames.add(fullName);
							}
						}

					}
				}
			}
		}
	}","@Test(timeout = 4000)
  public void test2()  throws Throwable  {
      MockFile mockFile0 = new MockFile(""%Fk<7+HIj"", ""u(-NaPR/,~"");
      MockFile.createTempFile(""u(-NaPR/,~"", "".class"", (File) mockFile0);
      // Undeclared exception!
      try { 
        StubClassLoader.getStubInfosFromClassPath("":3fx.g<[q"");
        fail(""Expecting exception: NoClassDefFoundError"");
      
      } catch(NoClassDefFoundError e) {
         //
         // org/yaml/snakeyaml/representer/Representer
         //
         verifyException(""es.bsc.dataclay.util.management.stubs.StubClassLoader"", e);
      }
  }",Get class names except ones in package provided @param actualSrcDir Actual directory @param srcDirectory directories @param classNames [out] File names @param extension Extension of classes to check @param packagesToExclude Packages to exclude
"public void closestPoint(final Point2D point, final Point2D result) {
        closestPoint(point, result, DEFAULT_THRESHOLD);
    }","@Test(timeout = 4000)
  public void test30()  throws Throwable  {
      InhomogeneousPoint2D inhomogeneousPoint2D0 = new InhomogeneousPoint2D();
      Triangle2D triangle2D0 = new Triangle2D(inhomogeneousPoint2D0, inhomogeneousPoint2D0, inhomogeneousPoint2D0);
      // Undeclared exception!
      try { 
        triangle2D0.getClosestPoint((Point2D) inhomogeneousPoint2D0);
        fail(""Expecting exception: NoClassDefFoundError"");
      
      } catch(NoClassDefFoundError e) {
         //
         // com/irurueta/geometry/Line2D
         //
         verifyException(""com.irurueta.geometry.Triangle2D"", e);
      }
  }",Computes the point which is locus of this triangle closest to provided point and stores the result in provided result point.@param point Point to be checked. @param result Point where result will be stored.
"public int toInt() {
        if (mValue == null) {
            return 0;
        }

        if (mValue.length > 2) {
            throw new UnsupportedOperationException(""Only supported for Identifiers with max byte length of 2"");
        }
        int result = 0;

        for (int i = 0; i < mValue.length; i++) {
            result |= (mValue[i] & 0xFF) << ((mValue.length - i - 1) * 8);
        }

        return result;
    }","@Test(timeout = 4000)
  public void test22()  throws Throwable  {
      BeaconIdentifier beaconIdentifier0 = BeaconIdentifier.fromInt(3167);
      String string0 = beaconIdentifier0.toString();
      assertEquals(""95"", string0);
  }",Represents the value as an <code>int<code>.@return value represented as int. @throws UnsupportedOperationException when value length is longer than 2.
"protected Iterator<K> createKeySetIterator() {
        if (size() == 0) {
            return EmptyIterator.INSTANCE;
        }
        return new KeySetIterator<K, V>(this);
    }","@Test(timeout = 4000)
  public void test35()  throws Throwable  {
      AbstractHashedMap<Object, Locale.FilteringMode> abstractHashedMap0 = new AbstractHashedMap<Object, Locale.FilteringMode>();
      AbstractHashedMap.KeySet<Object, Locale.FilteringMode> abstractHashedMap_KeySet0 = new AbstractHashedMap.KeySet<Object, Locale.FilteringMode>(abstractHashedMap0);
      // Undeclared exception!
      try { 
        abstractHashedMap_KeySet0.iterator();
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }",Creates a key set iterator. Subclasses can override this to return iterators with different properties. @return the keySet iterator
,"@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      ObjectStore<Object> objectStore0 = null;
      try {
        objectStore0 = new ObjectStore<Object>(1L);
        fail(""Expecting exception: NoClassDefFoundError"");
      
      } catch(NoClassDefFoundError e) {
         //
         // org/apache/logging/log4j/LogManager
         //
         verifyException(""net.dschinghiskahn.objectstore.ObjectStore"", e);
      }
  }",
"@SuppressWarnings(""UnusedReturnValue"")
    private static int selecti(final int k, final int indxOffset, final int[] indx, final int n,
                               final int arrOffset, final double[] arr) {
        int i;
        int ia;
        int ir = n - 1;
        int j;
        int l = 0;
        int mid;
        double a;

        for (; ; ) {
            if (ir <= l + 1) {
                if (ir == l + 1 && arr[arrOffset + indx[indxOffset + ir]] < arr[arrOffset + indx[indxOffset + l]]) {
                    swap(indx, indxOffset + l, indx, indxOffset + ir);
                }
                return indx[indxOffset + k];
            } else {
                mid = (l + ir) >> 1;
                swap(indx, indxOffset + mid, indx, indxOffset + l + 1);
                if (arr[arrOffset + indx[indxOffset + l]] > arr[arrOffset + indx[indxOffset + ir]]) {
                    swap(indx, indxOffset + l, indx, indxOffset + ir);
                }
                if (arr[arrOffset + indx[indxOffset + l + 1]] > arr[arrOffset + indx[indxOffset + ir]]) {
                    swap(indx, indxOffset + l + 1, indx, indxOffset + ir);
                }
                if (arr[arrOffset + indx[indxOffset + l]] > arr[arrOffset + indx[indxOffset + l + 1]]) {
                    swap(indx, indxOffset + l, indx, indxOffset + l + 1);
                }
                i = l + 1;
                j = ir;
                ia = indx[indxOffset + l + 1];
                a = arr[arrOffset + ia];
                for (; ; ) {
                    do {
                        i++;
                    } while (arr[arrOffset + indx[indxOffset + i]] < a);
                    do {
                        j--;
                    } while (arr[arrOffset + indx[indxOffset + j]] > a);
                    if (j < i) {
                        break;
                    }
                    swap(indx, indxOffset + i, indx, indxOffset + j);
                }
                indx[indxOffset + l + 1] = indx[indxOffset + j];
                indx[indxOffset + j] = ia;
                if (j >= k) {
                    ir = j - 1;
                }
                if (j <= k) {
                    l = i;
                }
            }
        }
    }","@Test(timeout = 4000)
  public void test10()  throws Throwable  {
      LinkedList<Point3D> linkedList0 = new LinkedList<Point3D>();
      HomogeneousPoint3D homogeneousPoint3D0 = new HomogeneousPoint3D();
      linkedList0.offerFirst(homogeneousPoint3D0);
      InhomogeneousPoint3D inhomogeneousPoint3D0 = new InhomogeneousPoint3D(3, 3, 3);
      linkedList0.offerFirst(inhomogeneousPoint3D0);
      linkedList0.add((Point3D) homogeneousPoint3D0);
      KDTree3D kDTree3D0 = null;
      try {
        kDTree3D0 = new KDTree3D(linkedList0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -1
         //
         verifyException(""com.irurueta.geometry.KDTree"", e);
      }
  }","Makes a selection so that we obtain ordered index at provided k position so that distances are ordered in such a way that resulting array arr contains distances as follows: arr[indx[0 .. k-1]] &lt;= arr[indx[k]] &lt;= arr[indx[k+1 .. n]]. So that positions between 0 and k-1 are not in any particular order but is less than k position, and positions between k+1 and n neither have any particular order but is more than k position.@param k sorted position to retrieve. @param indxOffset offset where indx search starts. @param indx array to be sorted (i.e. selected). @param n length of arrays. @param arrOffset offset of distances array. This is usually equal to indxOffset. @param arr resulting array containing distances to each selected point. @return index of selected point."
"public static void validateKey(final String key, final boolean binary) {
    byte[] keyBytes = KeyUtil.getKeyBytes(key);
    int keyLength = keyBytes.length;

    if (keyLength > MAX_KEY_LENGTH) {
      throw KEY_TOO_LONG_EXCEPTION;
    }

    if (keyLength == 0) {
      throw KEY_EMPTY_EXCEPTION;
    }

    if(!binary) {
      for (byte b : keyBytes) {
        if (b == ' ' || b == '\n' || b == '\r' || b == 0) {
          throw new IllegalArgumentException(
              ""Key contains invalid characters:  ``"" + key + ""''"");
        }
      }
    }

  }","@Test(timeout = 4000)
  public void test01()  throws Throwable  {
      // Undeclared exception!
      try { 
        StringUtils.validateKey(""xX\""M?f["", false);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Key contains invalid characters:  ``xX\""M?f[''
         //
         verifyException(""net.spy.memcached.util.StringUtils"", e);
      }
  }",Check if a given key is valid to transmit.@param key the key to check. @param binary if binary protocol is used.
"private static int fontStyleToInt(FontStyle style) {
        switch (style) {
        case PLAIN:
            return java.awt.Font.PLAIN;
        case BOLD:
            return java.awt.Font.BOLD;
        case ITALIC:
            return java.awt.Font.ITALIC;
        default:
            return java.awt.Font.PLAIN;
        }
    }","@Test(timeout = 4000)
  public void test07()  throws Throwable  {
      Font font0 = new Font(""@g%*RA@p+Ca}6,^s)a"");
      double double0 = font0.getSize();
      assertEquals(18.0, double0, 0.01);
  }",Return a java.awt.Font style constant from FontStyle.@param style FontStyle value. @return A java.awt.Font style constant.
"protected void printHorizontalSeparator(final StringBuilder stringBuilder, final char leftConnector,
            final char middleConnector,
            final char rightConnector) {
        if (isPrintLeftBorder()) {
            stringBuilder.append(leftConnector);
            append(stringBuilder, borderConfiguration.getHorizontalLine(), getColumnSpacing());
        }
        append(stringBuilder, borderConfiguration.getHorizontalLine(), columnWidths[0]);
        for (int i = 1; i < columnCount; i++) {
            if (isPrintColumnSeparators()) {
                append(stringBuilder, borderConfiguration.getHorizontalLine(), getColumnSpacing());
                stringBuilder.append(middleConnector);
                append(stringBuilder, borderConfiguration.getHorizontalLine(), getColumnSpacing());
            }
            append(stringBuilder, borderConfiguration.getHorizontalLine(), columnWidths[i]);
        }
        if (isPrintRightBorder()) {
            append(stringBuilder, borderConfiguration.getHorizontalLine(), getColumnSpacing());
            stringBuilder.append(rightConnector);
        }
        stringBuilder.append('\n');
    }","@Test(timeout = 4000)
  public void test04()  throws Throwable  {
      ConsoleTable consoleTable0 = new ConsoleTable(3);
      String[] stringArray0 = new String[3];
      stringArray0[0] = "" columns, but there are "";
      consoleTable0.addRow(stringArray0);
      String string0 = consoleTable0.toString();
      assertEquals(""--------------------------+--+--+\n|  columns, but there are  |  |  |\n--------------------------+--+--+\n"", string0);
  }","Fügt einen horizontalen Trennstrich inclusive Zeilenumbruch ein. @param stringBuilder StringBuilder, an den der Trennstrich angehängt werden soll. @param leftConnector Symbol für den Anschluss des linken Tabellenrands. @param middleConnector Symbol für den Anschluss von Rahmen in der Mitte. @param rightConnector Symbol für den Anschluss des rechten Tabellenrands."
"public static ImplementationID newImplementationID(final String uuidStr) {
		ID id = dataClayIDs.get(uuidStr);
		if (id == null) {
			// For more information about locking design, see Pool
			synchronized (dataClayIDs) { // ensure only one is created per object
				id = dataClayIDs.get(uuidStr);
				if (id == null) {
					id = new ImplementationID(uuidStr);
					dataClayIDs.put(uuidStr, id);
				}
			}
		}
		return (ImplementationID) id;
	}","@Test(timeout = 4000)
  public void test27()  throws Throwable  {
      ImplementationID implementationID0 = DataClayIDFactory.newImplementationID(""b{T%l%xti@-s]<"");
      assertNull(implementationID0);
  }",Create a new ImplementationID. @param uuidStr UUID string representation. @return ImplementationID.
"public static String[] getFilePathAndName(String fullFileName) {
		String[] filePathAndName = new String[2];
		int lastSlashIdx = fullFileName.lastIndexOf('/');
		if (lastSlashIdx != -1) {
			filePathAndName[0] = fullFileName.substring(0, lastSlashIdx + 1);
			filePathAndName[1] = fullFileName.substring(lastSlashIdx + 1);
		} else {
			filePathAndName[0] = """";
			filePathAndName[1] = fullFileName;
		}
		return filePathAndName;
	}","@Test(timeout = 4000)
  public void test07()  throws Throwable  {
      // Undeclared exception!
      try { 
        FileUtil.encodeFileName(""/,x9lFDmS/uh`]Z7Ha"");
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.net.URLEncoder"", e);
      }
  }","Return a String[2] with the first element being the file path (up to and including the last ''), and the second element as the file name (including extension). If the fullFileName has no path, then [0] is empty string, and [1] if the file name Note: Supports only '' file deliminator."
"public boolean addTimeSlot(long startTime, long finishTime, RangeList list) {		
		if(finishTime <= startTime) {
			return false;
		}
		Iterator<SingleProfileEntry> it = avail.itValuesFromPrec(startTime);
        SingleProfileEntry last = it.next();
        SingleProfileEntry newAnchor = null;

        if (last.getTime() < startTime) {
        	newAnchor = last.clone(startTime);
        	last = newAnchor;
        }

        SingleProfileEntry nextEntry = null;
        while(it.hasNext()) {
       		nextEntry = it.next();
       		if(nextEntry.getTime() > finishTime) {
       			break;
       		}
       			
       		// Remove duplicate entries. That is, entries whose PE ranges 
       		// are the same. This minimises the number of entries required
       		if(nextEntry.getTime() < finishTime && 
       				last.getAvailRanges().equals(nextEntry.getAvailRanges())) {
       			it.remove();
       		}
       		else {
	       		last.getAvailRanges().addAll(list.clone());
	       		last = nextEntry;
       		}
        }

        if (last.getTime() < finishTime) {
        	add(last.clone(finishTime));
        	last.getAvailRanges().addAll(list.clone());
        }
        
        if(newAnchor != null) {
        	add(newAnchor);
        }
        
        return true;
	}","@Test(timeout = 4000)
  public void test4()  throws Throwable  {
      SingleProfile singleProfile0 = new SingleProfile(1);
      RangeList rangeList0 = new RangeList();
      // Undeclared exception!
      try { 
        singleProfile0.addTimeSlot(1, 1074, rangeList0);
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""me.marcosassuncao.servsim.profile.SingleProfile"", e);
      }
  }",Includes a time slot in this availability profile. This is useful if your scheduling strategy cancels a job and you want to update the availability profile. @param startTime the start time of the time slot. @param finishTime the finish time of the time slot. @param list the list of ranges of resources in the slot. @return <tt>true<tt> if the slot was included; <tt>false<tt> otherwise.
"public static String getTypeNameFromSignatureOrDescriptor(final String signature) {
		final int arrayDimension = countOccurrences(signature, ""["");
		String typeName = signature.replace(""["", """");
		switch (typeName) {
		default:
			typeName = typeName.substring(1, typeName.length() - 1).replace(""/"", ""."");
			break;
		case ""Z"":
			typeName = ""boolean"";
			break;
		case ""I"":
			typeName = ""int"";
			break;
		case ""F"":
			typeName = ""float"";
			break;
		case ""J"":
			typeName = ""long"";
			break;
		case ""S"":
			typeName = ""short"";
			break;
		case ""C"":
			typeName = ""char"";
			break;
		case ""B"":
			typeName = ""byte"";
			break;
		case ""D"":
			typeName = ""double"";
			break;
		case ""V"":
			typeName = ""void"";
			break;
		}
		for (int i = 0; i < arrayDimension; ++i) {
			typeName += ""[]"";
		}
		return typeName;

	}","@Test(timeout = 4000)
  public void test59()  throws Throwable  {
      String string0 = Reflector.getTypeNameFromSignatureOrDescriptor(""[==PREFETCHING==] Adding lazy task."");
      assertEquals(""==PREFETCHING==] Adding lazy task.[]"", string0);
  }",Get the name of the type corresponding to the provided signature. @param signature Signature to analyze @return The name of the type corresponding to the provided signature.
"CMAAssetFile setUrl(String url) {
    this.url = url;
    return this;
  }","@Test(timeout = 4000)
  public void test3()  throws Throwable  {
      CMAAssetFile cMAAssetFile0 = new CMAAssetFile();
      CMAAssetFile cMAAssetFile1 = cMAAssetFile0.setUrl(""hnS<G>8S@`p{gkVV{_"");
      assertNull(cMAAssetFile1.getUrl());
  }",Internal testing method for setting the url to an arbitrary value. (Only accessible from inside this repository.)
"public double distanceSquared(Vector3d v) {
        double dx = x - v.x;
        double dy = y - v.y;
        double dz = z - v.z;

        return dx * dx + dy * dy + dz * dz;
    }","@Test(timeout = 4000)
  public void test19()  throws Throwable  {
      Vector3d vector3d0 = new Vector3d(1009.2193506, 0.0, 0.0);
      double double0 = vector3d0.distanceSquared(vector3d0);
      assertEquals(1009.2193506, vector3d0.x, 0.01);
  }",Returns the squared of the Euclidean distance between this vector and vector v. @return squared distance between this vector and v
"public void setFlags(TapRequestFlag f) {
    if (!flagList.contains(f)) {
      if (!hasFlags) {
        hasFlags = true;
        extralength += 4;
        totalbody += 4;
      }
      if (f.equals(TapRequestFlag.BACKFILL)) {
        hasBackfill = true;
        totalbody += 8;
      }
      if (f.equals(TapRequestFlag.LIST_VBUCKETS)
        || f.equals(TapRequestFlag.TAKEOVER_VBUCKETS)) {
        hasVBucketList = true;
        totalbody += 2;
      }
      if (f.equals(TapRequestFlag.CHECKPOINT)) {
        hasVBucketCheckpoints = true;
        totalbody += 2;
      }
      flagList.add(f);
    }
  }","@Test(timeout = 4000)
  public void test07()  throws Throwable  {
      RequestMessage requestMessage0 = new RequestMessage();
      TapRequestFlag tapRequestFlag0 = TapRequestFlag.BACKFILL;
      requestMessage0.setFlags(tapRequestFlag0);
      TapRequestFlag tapRequestFlag1 = TapRequestFlag.FIX_BYTEORDER;
      requestMessage0.setFlags(tapRequestFlag1);
      assertEquals(40, requestMessage0.getTotalbody());
  }",Sets the flags for the tap stream. These flags decide what kind of tap stream will be received.@param f The flags to use for this tap stream.
"public static boolean delete(File file) {

        if (file == null) {
            return false;
        } else if (!file.isFile()) {
            return false;
        }

        return file.delete();
    }","@Test(timeout = 4000)
  public void test09()  throws Throwable  {
      // Undeclared exception!
      try { 
        FileUtil.delete((File) null);
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""casmi.util.FileUtil"", e);
      }
  }","Deletes a file.@param file A file to delete.@return <code>true<code> if the file was deleted, otherwise <code>false<code>."
"public static int findIndex(Object[] array,Object value){
        if (array == null || value == null){
            return -1;
        }
        int i = 0;
        for (Object obj : array){
            if (obj.equals(value)){
                return i;
            }
            i++;
        }
        return -1;
    }","@Test(timeout = 4000)
  public void test2()  throws Throwable  {
      // Undeclared exception!
      try { 
        CollectionUtil.findIndex((Object[]) null, (Object) null);
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""com.britesnow.snow.util.CollectionUtil"", e);
      }
  }","Find the index of a value inside an array. If not found, or any of the param is null, return -1 @param array The array to lookup the value (if null, return -1) @param value The value to lookup (if null, return -1) @return the index of the match value, or -1 is not found"
"public static boolean isWorkingDay(Date date) {
		return isWorkingDay(dateToCalendar(date));
	}","@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      MockDate mockDate0 = new MockDate((-2948), 2, (-2948), 0, 834);
      Date date0 = NorwegianDateUtil.addWorkingDaysToDate(mockDate0, 1);
      assertEquals(""Sat Feb 04 13:54:00 GMT 1057"", date0.toString());
  }","Will check if the given date is a working day. That is check if the given date is a weekend day or a national holiday.@param date The date to check. @return true if the given date is a working day, false otherwise."
"public boolean setTime(long time) {
		if(time < 0) {
			return false;
		}
		
		this.time = time;
		return true;
	}","@Test(timeout = 4000)
  public void test0()  throws Throwable  {
      SingleProfileEntry singleProfileEntry0 = new SingleProfileEntry(2159L);
      boolean boolean0 = singleProfileEntry0.setTime(0L);
      assertFalse(boolean0);
  }",Sets the time associated with this entry @param time the time associated with this entry @return {@code true} if the time has been set successfully or {@code false} otherwise.
"private static String split(String s) {
        int i = s.lastIndexOf('.');
        if (i < 0)
            return s;
        else
            return s.substring(i + 1);
    }","@Test(timeout = 4000)
  public void test3()  throws Throwable  {
      RtfParserException rtfParserException0 = new RtfParserException();
      RtfParserException rtfParserException1 = new RtfParserException(rtfParserException0);
      String string0 = rtfParserException1.toString();
      assertEquals(""com.lowagie.text.rtf.parser.exceptions.RtfParserException: org.evosuite.runtime.mock.java.lang.MockThrowable"", string0);
  }",Removes everything in a String that comes before a '.' @param s the original string @return the part that comes after the dot
"public WebSocketHandlerBuilder withPingSentAfterNoWritesFor(int duration, TimeUnit unit) {
        if (duration < 0) {
            throw new IllegalArgumentException(""The duration must be 0 or greater"");
        }
        Mutils.notNull(""unit"", unit);
        this.pingAfterWriteMillis = unit.toMillis(duration);
        return this;
    }","@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      MuWebSocketFactory muWebSocketFactory0 = mock(MuWebSocketFactory.class, new ViolatedAssumptionAnswer());
      WebSocketHandlerBuilder webSocketHandlerBuilder0 = WebSocketHandlerBuilder.webSocketHandler(muWebSocketFactory0);
      // Undeclared exception!
      try { 
        webSocketHandlerBuilder0.build();
        fail(""Expecting exception: NoClassDefFoundError"");
      
      } catch(NoClassDefFoundError e) {
         //
         // io/netty/handler/codec/http/HttpHeaders
         //
         verifyException(""io.muserver.WebSocketHandlerBuilder"", e);
      }
  }","Sets the amount of time to wait before sending a ping message if no messages having been sent. <p>The default is 30 seconds.<p> @param duration The allowed timeout duration, or 0 to disable timeouts. @param unit The unit of the duration. @return This builder"
"public void closestPoint(final Point2D point, final Point2D result) {
        // iterate over all vertices and compute their distance
        Iterator<Point2D> iterator = mVertices.iterator();
        Point2D prevPoint = iterator.next();
        // to increase accuracy
        prevPoint.normalize();

        Point2D curPoint;
        double bestDist = Double.MAX_VALUE;
        double dist;
        boolean found = false;
        final Line2D line = new Line2D();
        final Point2D pointInLine = Point2D.create();

        while (iterator.hasNext()) {
            curPoint = iterator.next();
            // to increase accuracy
            curPoint.normalize();

            // check if point lies in the segment of the boundary of this polygon
            if (point.isBetween(curPoint, prevPoint)) {
                result.setCoordinates(point);
                return;
            }

            line.setParametersFromPairOfPoints(curPoint, prevPoint);
            // to increase accuracy
            line.normalize();

            // find closest point to line
            line.closestPoint(point, pointInLine);
            // to increase accuracy
            pointInLine.normalize();

            if (pointInLine.isBetween(curPoint, prevPoint)) {
                // closest point lies within segment of polygon boundary, so we
                // keep distance and point
                dist = point.distanceTo(pointInLine);
                if (dist < bestDist) {
                    // a better point has been found
                    bestDist = dist;
                    result.setCoordinates(pointInLine);
                    found = true;
                }
            }

            prevPoint = curPoint;
        }

        // try last vertex with first
        // check if point lies in the segment of the boundary of this polygon
        final Point2D first = mVertices.get(0);
        if (point.isBetween(prevPoint, first)) {
            result.setCoordinates(point);
            return;
        }

        line.setParametersFromPairOfPoints(prevPoint, first);
        // to increase accuracy
        line.normalize();

        // find closest point to line
        line.closestPoint(point, pointInLine);
        // to increase accuracy
        pointInLine.normalize();

        if (pointInLine.isBetween(prevPoint, first)) {
            // closest point lies within segment of polygon boundary, so we
            // keep distance
            dist = point.distanceTo(pointInLine);
            if (dist < bestDist) {
                // a better point has been found
                bestDist = dist;
                result.setCoordinates(pointInLine);
                found = true;
            }
        }


        if (!found) {
            // no closest point was found on a segment belonging to polygon
            // boundary so we search for the closest vertex
            iterator = mVertices.iterator();
            while (iterator.hasNext()) {
                curPoint = iterator.next();
                dist = point.distanceTo(curPoint);
                if (dist < bestDist) {
                    // a better vertex has been found
                    bestDist = dist;
                    result.setCoordinates(curPoint);
                }
            }
        }
    }","@Test(timeout = 4000)
  public void test12()  throws Throwable  {
      HomogeneousPoint2D homogeneousPoint2D0 = new HomogeneousPoint2D();
      Triangle2D triangle2D0 = new Triangle2D(homogeneousPoint2D0, homogeneousPoint2D0, homogeneousPoint2D0);
      List<Point2D> list0 = triangle2D0.getVertices();
      Polygon2D polygon2D0 = new Polygon2D(list0);
      // Undeclared exception!
      try { 
        polygon2D0.getClosestPoint(homogeneousPoint2D0);
        fail(""Expecting exception: NoClassDefFoundError"");
      
      } catch(NoClassDefFoundError e) {
         //
         // com/irurueta/geometry/Line2D
         //
         verifyException(""com.irurueta.geometry.Polygon2D"", e);
      }
  }","Computes the closes point to provided point that is locus of this polygon (i.e. lies on a border of this polygon).@param point Point to be checked. @param result Instance where the closest point will be stored.iterate over all vertices and compute their distance
to increase accuracy
try last vertex with first
check if point lies in the segment of the boundary of this polygon
to increase accuracy
find closest point to line
to increase accuracy"
"public boolean transition(int oldSnapshot, int newState) {
        int oldState = oldSnapshot & STATE_MASK;
        // Validate legal transition.
        if (shouldValidate) {
            if (!isValidTransition(oldState, newState)) {
                throw new IllegalArgumentException(String.format(""Can't transition from state %d to %d."", oldState, newState));
            }
        }
        int newSnapshot = ((oldSnapshot & INDEX_MASK) + INDEX_INCREMENTER) | newState;

        // The common case: we were asked to update something valid, and nothing invalidated our starting assumptions,
        // so we succeeded.
        if (stateSnapshot.compareAndSet(oldSnapshot, newSnapshot)) {
            if (listener != null) {
                // Don't report (non-)events where state wasn't updated.
                if (oldState != newState) {
                    listener.onCircuitTransition(this, oldState, newState);
                }
            }
            return true;

        // The second most common case: the atomic couldn't be updated, but it doesn't matter, because the
        // request was redundant (state was already correct). This happens when multiple threads ask for
        // the same transition.
        } else if ((stateSnapshot.get() & STATE_MASK) == newState) {
            return true;
        }

        // Otherwise our caller asked for something we can't honor. Typically this is because concurrency
        // invalidated the caller's view of what our current state was.
        return false;
    }","@Test(timeout = 4000)
  public void test29()  throws Throwable  {
      Circuit circuit0 = new Circuit((Circuit.Listener) null);
      circuit0.shouldValidate = true;
      // Undeclared exception!
      try { 
        circuit0.transition((-1136), (-1136));
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Can't transition from state -1133 to -1136.
         //
         verifyException(""co.codecraft.jcircuit.Circuit"", e);
      }
  }","<p>Attempt to move our state machine to a new state. This method should be called by {@link TransitionPolicy} objects, not the general public. (For direct manipulation of a circuit breaker, see {@link CircuitBreaker#directTransition(int, boolean)} instead.)<p><p>The request to transition will succeed if:<p> <ul> <li>The state machine is already in the requested state, making the transition redundant<li> <li><strong>OR<strong> the state has not changed since we last fetched it with {@link #getStateSnapshot()}<li> <ul><p>If {@link #shouldValidate} is true, then the correctness of old and new state are checked with each call, and an {@link IllegalArgumentException} is thrown if anomalies are detected. (This correctness is not evaluated against the actual state of the circuit, but rather against the asserted oldSnapshot. In other words, it can only generate an exception if the caller is coded wrong, not if the caller is unaware of the current state of the circuit.) This may be helpful while developing a new {@link CircuitBreaker}.<p>@param oldSnapshot Asserts that the circuit is currently in the state described by oldSnapshot. This value is returned by {@link #getStateSnapshot()}; it is more than one of the state constants ({@link #OPEN}, {@link #CLOSED}, etc). @param newState The new state that's desired. See {@link #OPEN}, {@link #CLOSED}, etc. @return true if the circuit is in the desired state when the function completes, false if not.Validate legal transition.
The common case: we were asked to update something valid, and nothing invalidated our starting assumptions,
so we succeeded.
Otherwise our caller asked for something we can't honor. Typically this is because concurrency
invalidated the caller's view of what our current state was."
"static Map<String, String> putIfNotSet(Map<String, String> target, Map<String, String> defaults) {
    boolean needsChange = defaults.keySet().stream().anyMatch(key -> !target.containsKey(key));
    if (needsChange) {
      Map<String, String> copy = new HashMap<>(target);
      for (final String key : defaults.keySet()) {
        if (!copy.containsKey(key)) {
          copy.put(key, defaults.get(key));
        }
      }
      return copy;
    }
    return target;
  }","@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      HashMap<String, String> hashMap0 = new HashMap<String, String>();
      HashMap<String, String> hashMap1 = DefaultQueryParameter.FETCH;
      Map<String, String> map0 = DefaultQueryParameter.putIfNotSet(hashMap0, hashMap1);
      assertEquals(0, map0.size());
  }","Update a given map with some default values if not already present in map.@param target the map to be filled with values, if a key for them is not set already. @param defaults the list of defaults, to be set. @return the same map if no change had to be made, a new map otherwise."
"public static String  getDeepValue(Map m, String namePath) {
		return getDeepValue(m,namePath,String.class);
	}","@Test(timeout = 4000)
  public void test17()  throws Throwable  {
      HashMap<String, String> hashMap0 = new HashMap<String, String>();
      // Undeclared exception!
      try { 
        MapUtil.getDeepValue((Map) hashMap0, ""oBtoIV6QBF9"");
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 2
         //
         verifyException(""com.britesnow.snow.util.MapUtil"", e);
      }
  }","@param m the nested map @param namePath the namePath (i.e. ""product.name"")"
"public static StringBuffer readContent( File file, Map<String[], String> replaceMap )
        throws IOException
    {
        StringBuffer content = new StringBuffer();

        BufferedReader reader = new BufferedReader( new InputStreamReader( new FileInputStream( file ), ENCODING_UTF8 ) );

        String line = null;

        String currentEndString = null;

        try
        {
            while ( (line = reader.readLine()) != null )
            {
                if ( currentEndString != null )
                {
                    if ( line.contains( currentEndString ) )
                    {
                        currentEndString = null;
                    }

                    continue;
                }

                if ( replaceMap != null )
                {
                    for ( Entry<String[], String> entry : replaceMap.entrySet() )
                    {
                        if ( line.contains( entry.getKey()[0] ) )
                        {
                            currentEndString = (entry.getKey()[1] != null && !line.contains( entry.getKey()[1] )) ? entry.getKey()[1] : null;

                            line = entry.getValue();

                            break;
                        }
                    }
                }

                content.append( line + LINE_BREAK );
            }
        }
        finally
        {
            try
            {
                reader.close();
            }
            catch ( Exception ex )
            {
            }
        }

        return content;
    }","@Test(timeout = 4000)
  public void test04()  throws Throwable  {
      URI uRI0 = MockURI.aFileURI;
      MockFile mockFile0 = new MockFile(uRI0);
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(mockFile0);
      mockFileOutputStream0.write((-1500));
      HashMap<String[], String> hashMap0 = new HashMap<String[], String>();
      String[] stringArray0 = new String[4];
      stringArray0[0] = """";
      hashMap0.put(stringArray0, ""UTF-8"");
      StringBuffer stringBuffer0 = StreamUtils.readContent(mockFile0, hashMap0);
      assertEquals(2, stringBuffer0.length());
  }","Reads the content of the file to a StringBuffer. Each line is compared to the keys of the argument map. If a line is matched, the line is replaced with the keys corresponding value. Passing null as replace map argument skips value replacement. The reading will stop at the first match for a single line.@param file the file to read from. @param replaceMap a map containing keys to be matched and values with replacements. @return a StringBuffer with the content of the file replaced according to the Map. @throws IOException if operation failed."
"@SuppressWarnings(""unchecked"")
  public <T> T getField(String key, String locale) {
    if (fields == null) {
      return null;
    }

    LinkedHashMap<String, Object> field = fields.get(key);
    if (field == null) {
      return null;
    } else {
      return (T) field.get(locale);
    }
  }","@Test(timeout = 4000)
  public void test00()  throws Throwable  {
      CMAEntry cMAEntry0 = new CMAEntry();
      CMAEntry.Localized cMAEntry_Localized0 = cMAEntry0.new Localized(""com.contentful.java.cma.model.CMAVisibility"");
      cMAEntry0.setField((String) null, (String) null, (Object) null);
      // Undeclared exception!
      try { 
        cMAEntry_Localized0.getField(""CMAEntry { CMAResource { system = CMASystem { space = CMALink { CMAResource { system = CMASystem { type = Link, linkType = Space, id =  } } } } } fields = null }"");
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""com.contentful.java.cma.model.CMAEntry"", e);
      }
  }","Return a specific localized field.@param key the key of the field @param locale the locale of the key @param <T> the type of the return value @return the value requested or null, if something (fields, key, locale) was not found."
,"@Test(timeout = 4000)
  public void test12()  throws Throwable  {
      LogCollector logCollector0 = new LogCollector();
      Vector<String> vector0 = logCollector0.getWarnings();
      assertNull(vector0);
  }",
,"@Test(timeout = 4000)
  public void test2()  throws Throwable  {
      Feature.FeatureType feature_FeatureType0 = Feature.FeatureType.QUALITATIVE;
      feature_FeatureType0.setParent(feature_FeatureType0);
      assertNull(feature_FeatureType0.getParent());
  }",
"public static double getFrequency(final double k) {
        //k = c / (4*pi*f) --> f = c / (4*pi*k)
        return SPEED_OF_LIGHT / (4.0 * Math.PI * k);
    }","@Test(timeout = 4000)
  public void test6()  throws Throwable  {
      double double0 = AltBeaconUtils.getFrequency(0.0, 0.0);
      assertEquals(Double.POSITIVE_INFINITY, double0, 0.01);
  }",Gets frequency from k value.@param k k value. @return frequency expressed in Hz.k = c (4pif) --> f = c (4pik)
"@Override
    public double test(final Map<String, Double> target, final Map<String, Double> baseline) {
        final double[] b = new double[baseline.keySet().size()];//baseline
        final double[] t = new double[target.keySet().size()];//target
        int c = 0;
        for (final String key : baseline.keySet()) {
            b[c] = baseline.get(key).doubleValue();
            t[c] = target.get(key).doubleValue();
            c++;
        }
        final double trueDiff = Math.abs(BasicStats.mean(b) - BasicStats.mean(t));
        double pvalue = 0.0;
        final double[] pb = new double[baseline.keySet().size()];//permutation of baseline
        final double[] pt = new double[target.keySet().size()];//permutation of target
        for (int i = 0; i < nPermutation; i++) {
            final char[] bits = randomBitVector(b.length).toCharArray();
            for (int j = 0; j < b.length; j++) {
                if (bits[j] == '0') {
                    pb[j] = b[j];
                    pt[j] = t[j];
                } else {
                    pb[j] = t[j];
                    pt[j] = b[j];
                }
            }
            final double pDiff = Math.abs(BasicStats.mean(pb) - BasicStats.mean(pt));
            if (pDiff >= trueDiff) {
                pvalue += 1.0;
            }
        }
        return pvalue / nPermutation;
    }","@Test(timeout = 4000)
  public void test0()  throws Throwable  {
      RandomPermutationTest randomPermutationTest0 = new RandomPermutationTest();
      HashMap<String, Double> hashMap0 = new HashMap<String, Double>();
      RandomPermutationTest.nPermutation = 2038;
      Double double0 = new Double(2038);
      hashMap0.put(""0DhESW0"", double0);
      double double1 = randomPermutationTest0.test(hashMap0, hashMap0);
      assertEquals(0.0, double1, 0.01);
  }","Run the randomization test @param baseline @param target @returnbaseline
target
permutation of baseline
permutation of target"
,"@Test(timeout = 4000)
  public void test02()  throws Throwable  {
      CMAConstraint.Equals cMAConstraint_Equals0 = new CMAConstraint.Equals();
      // Undeclared exception!
      try { 
        cMAConstraint_Equals0.getValue();
        fail(""Expecting exception: IndexOutOfBoundsException"");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 1, Size: 0
         //
         verifyException(""java.util.ArrayList"", e);
      }
  }",
"private static List<Triangle2D> internalTriangulate(
            final List<Point2D> verticesCopy, final List<int[]> indices,
            final List<Point2D> originalVertices) throws TriangulatorException {
        if (verticesCopy.size() < MIN_VERTICES) {
            throw new TriangulatorException();
        }

        final List<Triangle2D> result = new LinkedList<>();

        boolean madeCut;

        Triangle2D triangle = null;

        // Second, apply algorithm
        while (verticesCopy.size() > MIN_VERTICES) {
            madeCut = false;
            final int lastElement = verticesCopy.size() - 1;
            for (int i = 0; i <= lastElement; i++) {

                if (i == 0) {
                    if (triangle == null) {
                        // instantiate triangle if not already instantiated
                        triangle = new Triangle2D(verticesCopy.get(lastElement),
                                verticesCopy.get(0), verticesCopy.get(1));
                    } else {
                        triangle.setVertices(verticesCopy.get(lastElement),
                                verticesCopy.get(0), verticesCopy.get(1));
                    }
                } else if (i == lastElement) {
                    triangle.setVertices(verticesCopy.get(lastElement - 1),
                            verticesCopy.get(lastElement),
                            verticesCopy.get(0));
                } else {
                    triangle.setVertices(verticesCopy.get(i - 1),
                            verticesCopy.get(i), verticesCopy.get(i + 1));
                }

                if (isEar(triangle, verticesCopy)) {
                    // If it is an ear, we build a face out of the triangle being
                    // cut and remove it from polygon by cutting it
                    result.add(triangle);
                    // so that it cannot be reused after being added
                    triangle = null;

                    // cut ear
                    verticesCopy.remove(i);
                    madeCut = true;

                    // Leave from FOR loop to loop again to new reduced vertices set
                    break;
                }
            }

            // if arrived here but no cut was made and polygon size contains
            // more than 3 vertices, then the algorithm failed for some reason
            if (!madeCut) {
                throw new TriangulatorException();
            }
        }

        // instantiate final triangle
        triangle = new Triangle2D(verticesCopy.get(0),
                verticesCopy.get(1), verticesCopy.get(2));


        final boolean arePointsColinear = triangle.areVerticesColinear();

        // only add final triangle if not co-linear (area greater than small
        // threshold)
        if (!arePointsColinear)
            result.add(triangle);

        // add indices of triangles verticesCopy
        computeIndices(originalVertices, result, indices);

        return result;
    }","@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      VanGoghTriangulator2D vanGoghTriangulator2D0 = new VanGoghTriangulator2D();
      InhomogeneousPoint2D inhomogeneousPoint2D0 = new InhomogeneousPoint2D();
      HomogeneousPoint2D homogeneousPoint2D0 = new HomogeneousPoint2D(3, 3, 3);
      Triangle2D triangle2D0 = new Triangle2D(inhomogeneousPoint2D0, inhomogeneousPoint2D0, homogeneousPoint2D0);
      List<Point2D> list0 = triangle2D0.getVertices();
      LinkedList<Point2D> linkedList0 = new LinkedList<Point2D>(list0);
      Polygon2D polygon2D0 = new Polygon2D(linkedList0);
      Point2D point2D0 = polygon2D0.getCenter();
      linkedList0.add((Point2D) inhomogeneousPoint2D0);
      linkedList0.addFirst(point2D0);
      // Undeclared exception!
      try { 
        vanGoghTriangulator2D0.triangulate((List<Point2D>) linkedList0);
        fail(""Expecting exception: IndexOutOfBoundsException"");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 5, Size: 5
         //
         verifyException(""java.util.ArrayList"", e);
      }
  }","Internal method that computes the actual triangulation.@param verticesCopy List of points considered as verticesCopy of a polygon. This list will be modified after execution of this method. @param indices List where indices of original verticesCopy will be stored. This list can be used to refer to the original order of verticesCopy. Notice that verticesCopy indices might be repeated because verticesCopy might appear in more than one triangle after triangulation. If this parameter is null, indices won't be stored in this list. @param originalVertices Reference to original list of vertices that won't be modified. @return List of triangles forming the polygon that has been triangulated. @throws TriangulatorException Raised if triangulation cannot be done. Usually this indicates numerical instability or polygon degeneracy.Second, apply algorithm
instantiate final triangle
only add final triangle if not co-linear (area greater than small
threshold)
add indices of triangles verticesCopy"
"public long getDuration() {
		return finishTime - startTime;
	}","@Test(timeout = 4000)
  public void test02()  throws Throwable  {
      TimeSlot timeSlot0 = new TimeSlot((-280L), (-1L), (RangeList) null);
      boolean boolean0 = timeSlot0.setResourceRanges((RangeList) null);
      assertFalse(boolean0);
  }",Returns the time duration of this time slot. @return the time duration of this time slot.
,"@Test(timeout = 4000)
  public void test2()  throws Throwable  {
      Set set0 = XhtmlRendererFactory.getSupportedTypes();
      assertEquals(10, set0.size());
  }",
"public static <T> void removeAll( List<T> list, List<Integer> indexes )
    {
        if ( list == null || indexes == null )
        {
            return;
        }
        
        Collections.sort( indexes, Collections.reverseOrder() );
        
        final int size = list.size();
        
        for ( Integer index : indexes )
        {
            if ( index >= 0 && index < size )
            {
                list.remove( (int) index );
            }
        }
    }","@Test(timeout = 4000)
  public void test06()  throws Throwable  {
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add(""a] 0PK`MDYv}TO11"");
      // Undeclared exception!
      try { 
        ListUtils.removeEmptys(linkedList0);
        fail(""Expecting exception: NoClassDefFoundError"");
      
      } catch(NoClassDefFoundError e) {
         //
         // org/apache/commons/lang3/StringUtils
         //
         verifyException(""org.hisp.dhis.commons.collection.ListUtils"", e);
      }
  }",Removes from the given list the elements at the given indexes. Ignores indexes which are out of bounds of list. @param <T> type. @param list the list to remove elements from. @param indexes the indexes for the elements to remove.
"public static String generatePythonClass(final String className, final String parentName, final int level) {
		final StringBuffer result = new StringBuffer();
		// prepare indentation
		result.append(generateIndent(level));
		// prepare class
		result.append(""class "" + className + ""("");
		if (parentName != null) {
			result.append(parentName);
		} else {
			result.append(""object"");
		}
		result.append(""):\n"");
		return result.toString();
	}","@Test(timeout = 4000)
  public void test3()  throws Throwable  {
      String string0 = LineFactory.generatePythonClass("""", (String) null, 0);
      assertEquals(""class (object"", string0);
  }","Generates a class definition in Python for class @param className Name of the class @param parentName Name of the parent class (may be NULL) @param level Indentation level to use. @return An string defining the class using Python syntax ""[_indent_level]class className(parentName):\n""prepare indentation
prepare class"
,"@Test(timeout = 4000)
  public void test05()  throws Throwable  {
      CMAAsset.Fields cMAAsset_Fields0 = new CMAAsset.Fields();
      CMAAsset.Fields.Localized cMAAsset_Fields_Localized0 = cMAAsset_Fields0.localize(""Q/J"");
      // Undeclared exception!
      try { 
        cMAAsset_Fields_Localized0.setTitle(""CMAAsset.Fields {description = null, file = null, title = null}"");
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""com.contentful.java.cma.model.CMAAsset$Fields"", e);
      }
  }",
,"@Test(timeout = 4000)
  public void test4()  throws Throwable  {
      AtomicReference<Object> atomicReference0 = new AtomicReference<Object>();
      OperationFuture<Object> operationFuture0 = new OperationFuture<Object>(""x"", (CountDownLatch) null, atomicReference0, 170L, (ExecutorService) null);
      // Undeclared exception!
      try { 
        operationFuture0.signalComplete();
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.util.ArrayList"", e);
      }
  }",
"public static Integer zpvc( Number... values )
    {
        if ( values == null || values.length == 0 )
        {
            throw new IllegalArgumentException( ""Argument is null or empty: "" + values );
        }
        
        int count = 0;
        
        for ( Number value : values )
        {
            if ( value != null && value.doubleValue() >= 0d )
            {
                count++;
            }
        }
        
        return count;        
    }","@Test(timeout = 4000)
  public void test00()  throws Throwable  {
      Number[] numberArray0 = new Number[2];
      Long long0 = new Long(0L);
      numberArray0[0] = (Number) long0;
      // Undeclared exception!
      try { 
        ExpressionFunctions.zpvc(numberArray0);
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.hisp.dhis.commons.util.ExpressionFunctions"", e);
      }
  }",Function which will return the count of zero or positive values among the given argument values. @param values the arguments. @return an Integer.
,"@Test(timeout = 4000)
  public void test01()  throws Throwable  {
      ResourcePartition[] resourcePartitionArray0 = new ResourcePartition[0];
      PartProfile partProfile0 = new PartProfile(resourcePartitionArray0);
      PartProfileEntry partProfileEntry0 = new PartProfileEntry(3122L, 3512);
      partProfile0.add(partProfileEntry0);
      String string0 = partProfile0.toString();
      assertEquals(""Profile={\nProfileEntry={time=3122; gridlets=1; numPE=0}\n}"", string0);
  }",
"public static String getUUID() {
        return UUID.randomUUID().toString().replaceAll(""-"", """");
    }","@Test(timeout = 4000)
  public void test0()  throws Throwable  {
      String[] stringArray0 = UUIDUtils.getUUID(2840);
      assertNull(stringArray0);
  }",获得一个去掉“-”符号的UUID@return StringUUID
,"@Test(timeout = 4000)
  public void test2()  throws Throwable  {
      // Undeclared exception!
      try { 
        StripedLock.create();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 16
         //
         verifyException(""com.github.edgar615.util.concurrent.StripedLock"", e);
      }
  }",
"@Override
    public List<Triangle3D> triangulate(final Polygon3D polygon)
            throws TriangulatorException {
        // triangulation will modify provided list of vertices so we make a copy
        // of it

        //original vertices
        final List<Point3D> vertices = polygon.getVertices();
        final List<Point3D> verticesCopy = new ArrayList<>(
                polygon.getVertices());
        return internalTriangulate(verticesCopy, null, vertices);
    }","@Test(timeout = 4000)
  public void test04()  throws Throwable  {
      VanGoghTriangulator3D vanGoghTriangulator3D0 = new VanGoghTriangulator3D();
      InhomogeneousPoint3D inhomogeneousPoint3D0 = new InhomogeneousPoint3D(3, 3, 1.5707963267948966);
      Triangle3D triangle3D0 = new Triangle3D(inhomogeneousPoint3D0, inhomogeneousPoint3D0, inhomogeneousPoint3D0);
      List<Point3D> list0 = triangle3D0.getVertices();
      LinkedList<int[]> linkedList0 = new LinkedList<int[]>();
      try { 
        vanGoghTriangulator3D0.triangulate(list0, (List<int[]>) linkedList0);
        fail(""Expecting exception: Exception"");
      
      } catch(Exception e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""com.irurueta.geometry.VanGoghTriangulator3D"", e);
      }
  }","Triangulates provided polygon by dividing it into a set of triangles.@param polygon Polygon to be triangulated. @return List of triangles forming the polygon that has been triangulated. @throws TriangulatorException Raised if triangulation cannot be done. Usually this indicates numerical instability or polygon degeneracy.triangulation will modify provided list of vertices so we make a copy
of it
original vertices"
"public static <T> int getDistinctResultCount(int num, Callable<T> callable)
    throws Throwable {
    IdentityHashMap<T, Object> found = new IdentityHashMap<T, Object>();
    Collection<SyncThread<T>> threads = getCompletedThreads(num, callable);
    for (SyncThread<T> s : threads) {
      found.put(s.getResult(), new Object());
    }
    return found.size();
  }","@Test(timeout = 4000)
  public void test3()  throws Throwable  {
      Callable<Object> callable0 = (Callable<Object>) mock(Callable.class, new ViolatedAssumptionAnswer());
      doReturn((Object) null).when(callable0).call();
      int int0 = SyncThread.getDistinctResultCount(1, callable0);
      assertEquals(0, int0);
  }",Get the distinct result count for the given callable at the given concurrency.@param <T> the type of the callable @param num the concurrency @param callable the callable to invoke @return the number of distinct (by identity) results found @throws Throwable if an exception occurred in one of the invocations
"public static <L, R> Pair<L, R> of(L left, R right) {
        Pair<L, R> pair = new Pair<L, R>();
        pair.left = left;
        pair.right = right;
        return pair;
    }","@Test(timeout = 4000)
  public void test0()  throws Throwable  {
      Integer integer0 = new Integer((-2089));
      Pair<Integer, Integer> pair0 = Pair.of(integer0, integer0);
      Integer integer1 = pair0.getRight();
      assertNull(integer1);
  }",Creates a new pair of these values.@param left The left side of the pair. @param right The right side of the pair. @return The pair.
"public static final String toASCII(String in) {
        try {
            return IDN.toASCII(in);
        } catch (Exception e) {
            // let's continue with the character by character encoding hack.
        }
        final StringBuilder sb = new StringBuilder();
        for (int i=0;i<in.length();i++) {
            try {
                sb.append(IDN.toASCII(in.substring(i, i + 1)));
            }
            catch (Exception e) {}
        }
        if (sb.length() == 0) {
            throw new RuntimeException(""Unable to convert "" + in + "" to ASCII"");
        }
        return sb.toString();
    }","@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      // Undeclared exception!
      try { 
        FakerIDN.toASCII("""");
        fail(""Expecting exception: RuntimeException"");
      
      } catch(RuntimeException e) {
         //
         // Unable to convert  to ASCII
         //
         verifyException(""com.github.javafaker.service.FakerIDN"", e);
      }
  }",{@link IDN#toASCII(String)} is too picky for our needs. It was throwing exceptions for fa.yml and he.yml as they're Bidi languages and something was causing them to die. This is kind of a brute force fix but it appears to fix the issue. @param in input @return ascii
"private static double normalizeAngle(final double angle, final double halfTurn) {
        double result = angle;
        final double fullTurn = 2.0 * halfTurn;
        
        if (result <= -halfTurn) {
            int nTurns = (int)Math.ceil(-result / fullTurn);
            result += nTurns * fullTurn;
            if (result > halfTurn) {
                result -= fullTurn;
            }
        }
        if (result > halfTurn) {
            int nTurns = (int)Math.ceil(result / fullTurn);
            result -= nTurns * fullTurn;
            if(result <= -halfTurn){
                result += fullTurn;
            }
        }
        return result;
    }","@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      double double0 = Utils.normalizeAngleDegrees((-3677.25641267999));
      assertEquals(0.010253986677071225, double0, 0.01);
  }",Normalizes an angle between the range -pi...pi (or -180...180) by adding or subtracting the required amount of turns. This method can work with angles expressed either on degrees or radians depending on the units used for the definition of a half turn. @param angle angle to be normalized. @param halfTurn the definition of a half turn (either in degrees or radians). @return the same angle but normalized.
,"@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      EventTypeOuter.EventTypeEnum eventTypeOuter_EventTypeEnum0 = EventTypeOuter.EventTypeEnum.PERSISTED_OBJ;
      // Undeclared exception!
      try { 
        eventTypeOuter_EventTypeEnum0.getPriority();
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""es.bsc.dataclay.util.events.EventTypeOuter$EventTypeEnum"", e);
      }
  }",
"private Set<String> filterResourceNames(Set<String> resourceNames, String prefix, String suffix) {
        Set<String> filteredResourceNames = new TreeSet<String>();
        for (String resourceName : resourceNames) {
            String fileName = resourceName.substring(resourceName.lastIndexOf(File.separator) + 1);
            if (fileName.startsWith(prefix) && fileName.endsWith(suffix)
                    && (fileName.length() > (prefix + suffix).length())) {
                filteredResourceNames.add(resourceName);
            } else {
                LOG.debug(""Filtering out resource: "" + resourceName + "" (filename: "" + fileName + "")"");
            }
        }
        return filteredResourceNames;
    }","@Test(timeout = 4000)
  public void test0()  throws Throwable  {
      FileSystemScanner fileSystemScanner0 = new FileSystemScanner();
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile(""?7"");
      FileSystemHandling.appendStringToFile(evoSuiteFile0, ""Scanning for filesystem resources at '"");
      Resource[] resourceArray0 = fileSystemScanner0.scanForResources("""", """", """");
      assertEquals(0, resourceArray0.length);
  }",Filters this list of resource names to only include the ones whose filename matches this prefix and this suffix.@param resourceNames The names to filter. @param prefix The prefix to match. @param suffix The suffix to match. @return The filtered names set.
"public static byte[] readJar(final String path) {
		byte[] result = null;
		try {
			final FileInputStream fis = new FileInputStream(path);
			// System.out.println(file.exists() + ""!!"");
			// InputStream in = resource.openStream();
			final ByteArrayOutputStream bos = new ByteArrayOutputStream();
			final byte[] buf = new byte[MAX_BYTES];
			int totalbytes = 0;
			int readNum = fis.read(buf);
			while (readNum != -1) {
				bos.write(buf, 0, readNum); // no doubt here is 0
				// Writes len bytes from the specified byte array starting at offset off to this byte array output stream.
				totalbytes += readNum;
				readNum = fis.read(buf);
			}
			System.out.println(""[DATACLAY] Library serialized: "" + totalbytes + "" bytes"");
			result = bos.toByteArray();
			fis.close();
		} catch (Exception e) {
			e.printStackTrace();
			throw new DataClayRuntimeException(ERRORCODE.ERROR_DEPLOYING_LIB, ""Error while reading Jar"", true);
		}
		return result;
	}","@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile(""?##lJy_[DW+!)"");
      FileSystemHandling.appendLineToFile(evoSuiteFile0, """");
      byte[] byteArray0 = JarUtils.readJar(""?##lJy_[DW+!)"");
      assertNull(byteArray0);
  }",Read Jar file into byte array @param path Path of the Jar file @return Byte array representation of the Jar file
,"@Test(timeout = 4000)
  public void test0()  throws Throwable  {
      InterfaceManagerSQLStatements.SqlStatements interfaceManagerSQLStatements_SqlStatements0 = InterfaceManagerSQLStatements.SqlStatements.DELETE_INTERFACE;
      InterfaceManagerSQLStatements.SqlStatements.loadStatements();
      String string0 = interfaceManagerSQLStatements_SqlStatements0.getSqlStatement();
      assertNull(string0);
  }",
,"@Test(timeout = 4000)
  public void test0()  throws Throwable  {
      MetaDataServiceSQLStatements.SqlStatements metaDataServiceSQLStatements_SqlStatements0 = MetaDataServiceSQLStatements.SqlStatements.SELECT_UNREGISTERED_EXTERNAL_OBJECTS;
      metaDataServiceSQLStatements_SqlStatements0.getSqlStatement();
      String string0 = metaDataServiceSQLStatements_SqlStatements0.getSqlStatement();
      assertNull(string0);
  }",
"public byte[] zip(String str) {
        GZIPOutputStream zipStream = null;
        try {
            ByteArrayOutputStream targetStream = new ByteArrayOutputStream();
            zipStream = new GZIPOutputStream(targetStream);
            zipStream.write(str.getBytes());
            zipStream.close();
            byte[] zipped = targetStream.toByteArray();
            targetStream.close();
            return zipped;
        } catch (IOException ex) {
            throw new RuntimeException(ex);
        } finally {
            try {
                if (zipStream != null) {
                    zipStream.close();
                }
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        }
    }","@Test(timeout = 4000)
  public void test0()  throws Throwable  {
      Zipper zipper0 = new Zipper();
      byte[] byteArray0 = zipper0.zip(""d>I|}SXe%"");
      assertEquals(20, byteArray0.length);
  }",zips up a string into a GZIP format.@param str The string to zip @return The zipped string
,"@Test(timeout = 4000)
  public void test03()  throws Throwable  {
      CMAEditorInterface.Control cMAEditorInterface_Control0 = new CMAEditorInterface.Control();
      // Undeclared exception!
      try { 
        cMAEditorInterface_Control0.addSetting(""1=$N5QG_\"""", ""com.contentful.java.cma.model.CMAEditorInterface$Control$BuildInWidgetId"");
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""com.contentful.java.cma.model.CMAEditorInterface$Control"", e);
      }
  }",
"static public long calculateChecksum(byte[] buf) {
    int length = buf.length;
    int i = 0;

    long sum = 0;
    long data;

    // Handle all pairs
    while (length > 1) {
      // Corrected to include @Andy's edits and various comments on Stack Overflow
      data = (((buf[i] << 8) & 0xFF00) | ((buf[i + 1]) & 0xFF));
      sum += data;
      // 1's complement carry bit correction in 16-bits (detecting sign extension)
      if ((sum & 0xFFFF0000) > 0) {
        sum = sum & 0xFFFF;
        sum += 1;
      }

      i += 2;
      length -= 2;
    }

    // Handle remaining byte in odd length buffers
    if (length > 0) {
      // Corrected to include @Andy's edits and various comments on Stack Overflow
      sum += (buf[i] << 8 & 0xFF00);
      // 1's complement carry bit correction in 16-bits (detecting sign extension)
      if ((sum & 0xFFFF0000) > 0) {
        sum = sum & 0xFFFF;
        sum += 1;
      }
    }

    // Final 1's complement value correction to 16-bits
    sum = ~sum;
    sum = sum & 0xFFFF;
    return sum;

  }","@Test(timeout = 4000)
  public void test0()  throws Throwable  {
      byte[] byteArray0 = new byte[7];
      byteArray0[6] = (byte) (-1);
      long long0 = Checksum.calculateChecksum(byteArray0);
      assertEquals(65025L, long0);
  }","http:stackoverflow.comquestions4113890how-to-calculate-the-internet-checksum-from-a-byte-in-javaHandle all pairs
Handle remaining byte in odd length buffers
Final 1's complement value correction to 16-bits"
,"@Test(timeout = 4000)
  public void test3()  throws Throwable  {
      NodeDistanceComparator nodeDistanceComparator0 = new NodeDistanceComparator();
      NodeDistance nodeDistance0 = new NodeDistance((TreeNode) null, (TreeNode) null, 0.0);
      NodeDistance nodeDistance1 = new NodeDistance((TreeNode) null, (TreeNode) null, (-87.445115058));
      int int0 = nodeDistanceComparator0.compare(nodeDistance0, nodeDistance1);
      assertEquals(0, int0);
  }",
"public Extension getExtension() {
    if (extension == null) {
      extension = new Extension();
    }

    return extension;
  }","@Test(timeout = 4000)
  public void test3()  throws Throwable  {
      CMAUiExtension cMAUiExtension0 = new CMAUiExtension();
      String string0 = cMAUiExtension0.toString();
      assertEquals(""CMAUiExtension { CMAResource { system = CMASystem { type = UiExtension } } extension = null }"", string0);
  }",@return the extension description part of the UI extension.
,"@Test(timeout = 4000)
  public void test0()  throws Throwable  {
      LogicMetadataSQLStatements.SqlStatements logicMetadataSQLStatements_SqlStatements0 = LogicMetadataSQLStatements.SqlStatements.SELECT_EXECENV_BY_HOSTNAME_AND_PORT;
      logicMetadataSQLStatements_SqlStatements0.getSqlStatement();
      String string0 = logicMetadataSQLStatements_SqlStatements0.getSqlStatement();
      assertNull(string0);
  }",
"public static String byteToHex(byte b) {
        String hex = Integer.toHexString(b & 0xFF);
        if (hex.length() < 2) {
            hex = ""0"" + hex;
        }
        return hex;
    }","@Test(timeout = 4000)
  public void test4()  throws Throwable  {
      String string0 = HexUtils.byteToHex((byte)108);
      assertEquals(""ff"", string0);
  }",字节转十六进制@param b 需要进行转换的byte字节 @return 转换后的Hex字符串
"public static void main(final String[] args) throws Exception {
		if (args.length != 3) {
			Util.finishErr(""Bad arguments. Usage: \n\n "" + AccessNamespace.class.getSimpleName()
					+ "" <applicant_username> <applicant_pass> <namespace_name> \n"", ERRCODE.ERROR);
			return;
		}
		try {
			Util.init();

			final String applicantName = args[0];
			final String applicantPass = args[1];
			final String namespace = args[2];

			// Check account
			final AccountID applicantID = ClientManagementLib.getAccountID(applicantName);
			if (applicantID == null) {
				Util.finishErr(""Invalid account"", ERRCODE.ERROR);
				return;
			}
			final PasswordCredential applicantCredential = new PasswordCredential(applicantPass);

			// Check namespace
			final NamespaceID nspaceID = ClientManagementLib.getNamespaceID(applicantID, applicantCredential, namespace);
			if (nspaceID == null) {
				Util.finishErr(""Namespace "" + namespace + "" does not exist."", ERRCODE.ERROR);
				return;
			}

			ContractID contractID = null;
			final Map<ContractID, Contract> curContracts = ClientManagementLib.getContractsOfApplicant(applicantID,
					applicantCredential, nspaceID);
			if (curContracts != null && curContracts.size() != 0) {
				contractID = curContracts.keySet().iterator().next();
			} else {
				// Register to public contract of the namespace
				contractID = ClientManagementLib.registerToPublicContractOfNamespace(applicantID, applicantCredential,
						nspaceID);
			}

			if (contractID == null) {
				// ======== Create public contract with namespace provided ======

				final Map<MetaClassID, MetaClass> registeredClasses = ClientManagementLib.getClassesInfoInNamespace(applicantID, applicantCredential, nspaceID);

				// Parse info of metaclasses
				final List<InterfaceInContract> ifacesInContract = new ArrayList<>();
				for (final MetaClass currentMclassInfo : registeredClasses.values()) {
					final Set<String> operationsSignatures = new HashSet<>();
					final Set<OpImplementations> opImpls = new HashSet<>();
					final Map<OperationID, OpImplementations> actualOpImpls = new HashMap<>();
					for (final Operation op : currentMclassInfo.getOperations()) {
						operationsSignatures.add(op.getNameAndDescriptor());
						final OpImplementations opImplem = new OpImplementations(op.getNameAndDescriptor(), 0, 0);
						opImpls.add(opImplem);
						final ImplementationID implID = op.getImplementations().get(0).getDataClayID();
						opImplem.setLocalImplementationID(implID);
						opImplem.setRemoteImplementationID(implID);
						actualOpImpls.put(op.getDataClayID(), opImplem);
					}

					final Set<String> propNames = new HashSet<>();
					for (final Property prop : currentMclassInfo.getProperties()) {
						propNames.add(prop.getName());
					}

					// Create a new Interface for the class
					final Interface newInterface = new Interface(applicantName, namespace, namespace, currentMclassInfo.getName(),
							propNames, operationsSignatures);

					final InterfaceID newIfaceID = ClientManagementLib.newInterface(applicantID, applicantCredential, newInterface);
					if (newIfaceID != null) {
						// Update the interfaces in contract
						final InterfaceInContract interfaceInContract = new InterfaceInContract(newInterface, opImpls);
						interfaceInContract.setAccessibleImplementations(actualOpImpls);
						ifacesInContract.add(interfaceInContract);
					}
				}

				// Create public contract
				final Calendar beginDate = Calendar.getInstance();
				final Calendar endDate = Calendar.getInstance();
				beginDate.add(Calendar.YEAR, -1);
				endDate.add(Calendar.YEAR, 10);
				final Contract newContract = new Contract(namespace, applicantName, ifacesInContract, beginDate, endDate);
				ClientManagementLib.newPublicContract(applicantID, applicantCredential, newContract);

				// Register to public contract of the namespace
				contractID = ClientManagementLib.registerToPublicContractOfNamespace(applicantID, applicantCredential,
						nspaceID);
			}

			// TODO Notice that break line is needed for the global tool to ""tail"" the contract ID
			System.out.println(""User "" + applicantName + "" registered in data model of namespace: "" + namespace
					+ "" with contract ID: \n"" + contractID.toString());
		} catch (final Exception ex) {
			Util.finishErr(""Exception caught. Check your account and credentials."", ERRCODE.ERROR);
		}
		System.exit(0); // Call this to finish logging threads

	}","@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      String[] stringArray0 = new String[3];
      // Undeclared exception!
      try { 
        AccessNamespace.main(stringArray0);
        fail(""Expecting exception: NoClassDefFoundError"");
      
      } catch(NoClassDefFoundError e) {
         //
         // es/bsc/dataclay/commonruntime/DataClayRuntime
         //
         verifyException(""es.bsc.dataclay.tool.AccessNamespace"", e);
      }
  }",Call this to finish logging threads
"public static String generateHash(String pwd) {
		String encryptedPwd=""00000000"";
		String password = pwd;
		
		// if there is no password or the length is 0, then skip this and return ""00000000"" as default
		// otherwise process the password
		if(password != null && password.length() > 0) {
			// Truncate the password to 15 characters.
			if(password.length() > 15) {
				password = password.substring(0,15);
			}

			// compute key's high-order word
			// initialize to table value
			int hi = initialCodeArray[password.length()-1];
			
			int idxF = 0;	// forward index
			int idxR = password.length()-1; // reverse index
			// process each character left to right.
			// check each bit and if it is set, xor the hi word with 
			// the table entry for the position in password and bit position.
			for(; idxF<password.length(); idxF++,idxR--) {
				int ch = password.charAt(idxF);
				if((ch & 0x0001)!= 0) {
					hi ^= encryptionMatrix[idxR][0];
				}
				if((ch & 0x0002)!= 0) {
					hi ^= encryptionMatrix[idxR][1];
				}
				if((ch & 0x0004)!= 0) {
					hi ^= encryptionMatrix[idxR][2];
				}
				if((ch & 0x0008)!= 0) {
					hi ^= encryptionMatrix[idxR][3];
				}
				if((ch & 0x0010)!= 0) {
					hi ^= encryptionMatrix[idxR][4];
				}
				if((ch & 0x0020)!= 0) {
					hi ^= encryptionMatrix[idxR][5];
				}
				if((ch & 0x0040)!= 0) {
					hi ^= encryptionMatrix[idxR][6];
				}
			}
			// Compute Key's low-order word
			idxF = password.length()-1;
			int lo = 0;
			// low order word is computed in reverse.
			for(;idxF>= 0; idxF--) {
				int ch = password.charAt(idxF);
				lo = (((lo >> 14) & 0x001) | (( lo << 1) & 0x7fff)) ^ ch;
			}
			// finally incorporate the password length into the low word and use value from formula
			lo = (((lo >> 14) & 0x001) | (( lo << 1) & 0x7fff)) ^ password.length() ^ 0xCE4B;
			
			// correct for little-endian - 
			// Java always uses big-endian. According to tests - RTF wants little-endian but is not documented
			encryptedPwd = Integer.toHexString(lo).substring(2,4) + Integer.toHexString(lo).substring(0,2);
			encryptedPwd += Integer.toHexString(hi).substring(2,4) + Integer.toHexString(hi).substring(0,2);
		}
		return encryptedPwd;
	}","@Test(timeout = 4000)
  public void test2()  throws Throwable  {
      // Undeclared exception!
      try { 
        RtfProtection.generateHash(""Z_URt/a~)z*j&Y"");
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
      
      } catch(StringIndexOutOfBoundsException e) {
      }
  }","<code>generateHash<code> generates the password hash from a clear text string. @param pwd Clear text string input @return hex encoded password hash @since 2.1.1if there is no password or the length is 0, then skip this and return ""00000000"" as default
otherwise process the password"
"public static String getImageUrl(String pid, ImageSize imageSize, boolean https) {
        pid = pid.trim();
        String size = imageSize.name();
        // 传递 pid
        Pattern p = Pattern.compile(""^[a-zA-Z0-9]{32}$"");
        Matcher m = p.matcher(pid);

        if (m.matches()) {
            CRC32 crc32 = new CRC32();
            crc32.update(pid.getBytes());
            return (https ? ""https"" : ""http"") + ""://"" + (https ? ""ws"" : ""ww"")
                    + ((crc32.getValue() & 3) + 1) + "".sinaimg.cn/"" + size
                    + ""/"" + pid + ""."" + (pid.charAt(21) == 'g' ? ""gif"" : ""jpg"");
        }
        // 传递 url
        String url = pid;
        Pattern p1 = Pattern.compile(""^(https?://[a-z]{2}d.sinaimg.cn/)(large|bmiddle|mw1024|mw690|small|square|thumb180|thumbnail)(/[a-z0-9]{32}.(jpg|gif))$"");
        Matcher m1 = p1.matcher(url);
        if (m1.find()) {
            return m.group(1) + size + m.group(3);
        }
        return null;
    }","@Test(timeout = 4000)
  public void test3()  throws Throwable  {
      ImageSize imageSize0 = ImageSize.bmiddle;
      String string0 = WbpUtils.getImageUrl(""00000000000000000000000000000000"", imageSize0, true);
      assertEquals(""https://ws0.sinaimg.cn/bmiddle/00000000000000000000000000000000.jpg"", string0);
  }","本方法来自 @dong4j：https:github.comdong4j <p> Gets image url.@param pid the pid @param imageSize the imageSize @param https the https @return the image url传递 pid
传递 url"
"public static void main(String[] args) throws Exception {
		try {
			Util.init();

			final DataClayInstanceID dcID = ClientManagementLib.getDataClayID();
			Util.finishOut(dcID.toString());

		} catch (Exception ex) {
			ex.printStackTrace();
			Util.finishErr(""Exception caught: "" + ex.getLocalizedMessage() + ""."", ERRCODE.ERROR);
		}
		System.exit(0); // Call this to finish logging threads

	}","@Test(timeout = 4000)
  public void test0()  throws Throwable  {
      String[] stringArray0 = new String[2];
      // Undeclared exception!
      try { 
        GetCurrentDataClayID.main(stringArray0);
        fail(""Expecting exception: NoClassDefFoundError"");
      
      } catch(NoClassDefFoundError e) {
         //
         // es/bsc/dataclay/commonruntime/DataClayRuntime
         //
         verifyException(""es.bsc.dataclay.tool.GetCurrentDataClayID"", e);
      }
  }",Call this to finish logging threads
"public static String fromByte(byte model) {
        if (Arrays.asList(UNSUPPORTED_MAKE).contains(model)) {
            return UnsupportedDevice;
        }

        if (Arrays.asList(INVALID_MAKES).contains(model)) {
            return InvalidDevice;
        }
        if (model < MAKE_NAME_LOOKUP_TABLE.length) {
            return MAKE_NAME_LOOKUP_TABLE[model];
        }

        return UnknownDevice;
    }","@Test(timeout = 4000)
  public void test1()  throws Throwable  {
      String string0 = AcceptorModel.fromByte((byte)6);
      assertEquals(""Unknown Device"", string0);
  }",Retrieve model name from lookup table using standard acctype code@param model byte @return String
"@Override
    public double evaluate(double accelerometerMse, double gyroscopeMse,
                           double magnetometerMse) {
        return accelerometerMse + gyroscopeMse + magnetometerMse;
    }","@Test(timeout = 4000)
  public void test0()  throws Throwable  {
      DefaultAccelerometerGyroscopeAndMagnetometerMseRule defaultAccelerometerGyroscopeAndMagnetometerMseRule0 = new DefaultAccelerometerGyroscopeAndMagnetometerMseRule();
      double double0 = defaultAccelerometerGyroscopeAndMagnetometerMseRule0.evaluate(0.0, 1.0, 1.0);
      assertEquals(1.0, double0, 0.01);
  }","Evaluates provided accelerometer calibration MSE, gyroscope calibration MSE and magnetometer calibration MSE in order to obtain a single MSE value representing all three of them.@param accelerometerMse accelerometer calibration MSE. @param gyroscopeMse gyroscope calibration MSE. @param magnetometerMse magnetometer calibration MSE. @return single MSE value."
"public static Result convert(final Object res) throws QConnectorException {
		if (res == null) {
			return new EmptyResult();
		}
		// table
		if (res instanceof c.Flip) {
			return new FlipResult("""", (c.Flip) res);
		}
		// dict
		if (res instanceof c.Dict) {
			final c.Dict dict = (c.Dict) res;
			if ((dict.x instanceof c.Flip) && (dict.y instanceof c.Flip)) {
				final c.Flip key = (c.Flip) dict.x;
				final c.Flip data = (c.Flip) dict.y;
				return new FlipFlipResult("""", key, data);
			}
		}
		if (res instanceof Object[]) {
			final Object[] oa = (Object[]) res;
			if ((oa.length == 2) && (oa[0] instanceof String) && (oa[1] instanceof c.Flip)) {
				final String table = (String) oa[0];
				final c.Flip flip = (c.Flip) oa[1];
				return new FlipResult(table, flip);
			} else if ((oa.length == 3) && (oa[1] instanceof String) && (oa[2] instanceof c.Flip)) {
				final String table = (String) oa[1];
				final c.Flip flip = (c.Flip) oa[2];
				return new FlipResult(table, flip);
			} else {
				return new ListResult<Object>(oa);
			}
		}
		// list
		if (res instanceof byte[]) {
			return new ListResult<Byte>(ArrayUtils.toObject((byte[]) res));
		}
		if (res instanceof boolean[]) {
			return new ListResult<Boolean>(ArrayUtils.toObject((boolean[]) res));
		}
		if (res instanceof short[]) {
			return new ListResult<Short>(ArrayUtils.toObject((short[]) res));
		}
		if (res instanceof int[]) {
			return new ListResult<Integer>(ArrayUtils.toObject((int[]) res));
		}
		if (res instanceof long[]) {
			return new ListResult<Long>(ArrayUtils.toObject((long[]) res));
		}
		if (res instanceof float[]) {
			return new ListResult<Float>(ArrayUtils.toObject((float[]) res)); // q real
		}
		if (res instanceof double[]) {
			return new ListResult<Double>(ArrayUtils.toObject((double[]) res)); // q float
		}
		if (res instanceof char[]) {
			return new ListResult<Character>(ArrayUtils.toObject((char[]) res));
		}
		if (res.getClass().isArray()) {
			if (res.getClass().getComponentType() == String.class) { // q symbol
				return new ListResult<String>((String[]) res);
			}
			if (res.getClass().getComponentType() == java.sql.Timestamp.class) { // q timestamp
				return new ListResult<java.sql.Timestamp>((java.sql.Timestamp[]) res);
			}
			if (res.getClass().getComponentType() == kx.c.Minute.class) { // q minute
				return new ListResult<kx.c.Minute>((kx.c.Minute[]) res);
			}
			if (res.getClass().getComponentType() == kx.c.Second.class) { // q second
				return new ListResult<kx.c.Second>((kx.c.Second[]) res);
			}
			if (res.getClass().getComponentType() == kx.c.Month.class) { // q month
				return new ListResult<kx.c.Month>((kx.c.Month[]) res);
			}
			if (res.getClass().getComponentType() == java.sql.Time.class) { // q time
				return new ListResult<java.sql.Time>((java.sql.Time[]) res);
			}
			if (res.getClass().getComponentType() == java.sql.Date.class) { // q date
				return new ListResult<java.sql.Date>((java.sql.Date[]) res);
			}
			if (res.getClass().getComponentType() == java.util.Date.class) { // q datetime
				return new ListResult<java.util.Date>((java.util.Date[]) res);
			}
			if (res.getClass().getComponentType() == kx.c.Timespan.class) { // q timespan
				return new ListResult<kx.c.Timespan>((kx.c.Timespan[]) res);
			}
			if (res.getClass().getComponentType() == UUID.class) { // q guid
				return new ListResult<UUID>((UUID[]) res);
			}
		}
		// primitive
		if (res instanceof Boolean) {
			return new PrimitiveResult<Boolean>((Boolean) res);
		}
		if (res instanceof Byte) {
			return new PrimitiveResult<Byte>((Byte) res);
		}
		if (res instanceof Short) {
			return new PrimitiveResult<Short>((Short) res);
		}
		if (res instanceof Long) {
			return new PrimitiveResult<Long>((Long) res);
		}
		if (res instanceof Integer) {
			return new PrimitiveResult<Integer>((Integer) res);
		}
		if (res instanceof Float) { // q real
			return new PrimitiveResult<Float>((Float) res);
		}
		if (res instanceof Double) { // q float
			return new PrimitiveResult<Double>((Double) res);
		}
		if (res instanceof Character) { // q char
			return new PrimitiveResult<Character>((Character) res);
		}
		if (res instanceof String) { // q symbol
			return new PrimitiveResult<String>((String) res);
		}
		if (res instanceof java.sql.Timestamp) { // q timestamp
			return new PrimitiveResult<java.sql.Timestamp>((java.sql.Timestamp) res);
		}
		if (res instanceof kx.c.Minute) { // q minute
			return new PrimitiveResult<kx.c.Minute>((kx.c.Minute) res);
		}
		if (res instanceof kx.c.Second) { // q second
			return new PrimitiveResult<kx.c.Second>((kx.c.Second) res);
		}
		if (res instanceof kx.c.Month) { // q month
			return new PrimitiveResult<kx.c.Month>((kx.c.Month) res);
		}
		if (res instanceof java.sql.Time) { // q time
			return new PrimitiveResult<java.sql.Time>((java.sql.Time) res);
		}
		if (res instanceof java.sql.Date) { // q date
			return new PrimitiveResult<java.sql.Date>((java.sql.Date) res);
		}
		if (res instanceof java.util.Date) { // q datetime
			return new PrimitiveResult<java.util.Date>((java.util.Date) res);
		}
		if (res instanceof kx.c.Timespan) { // q timespan
			return new PrimitiveResult<kx.c.Timespan>((kx.c.Timespan) res);
		}
		if (res instanceof UUID) { // q guid
			return new PrimitiveResult<UUID>((UUID) res);
		}
		throw new QConnectorException(""Unsupported sync result type: "" + res.getClass());
	}","@Test(timeout = 4000)
  public void test7()  throws Throwable  {
      try { 
        CResultHelper.convert(""o%3@ogc^$@3|x0x"");
        fail(""Expecting exception: Exception"");
      
      } catch(Exception e) {
         //
         // Unsupported sync result type: class java.lang.String
         //
         verifyException(""info.michaelwittig.javaq.connector.impl.CResultHelper"", e);
      }
  }","Converts an result from the kx c library to a QConnector Result. @param res Result from q @return Result @throws QConnectorException If the result type is not supportedtable
dict
list
primitive"
"protected T calculate(FormulaEvaluatorConfiguration conf, T v1, T v2) {
    switch (conf.getDefaultNullHandling()) {
      case NULL:
        return v1 == null || v2 == null ? null : calculateDefault(conf, v1, v2);
      case ZERO:
        return calculateDefault(conf, v1 == null ? zero() : v1, v2 == null ? zero() : v2);
      default:
        if (v1 == null || v2 == null) {
          throw new FormulaEvaluatorNullArgumentException(this.getOperatorName(), asList(v1, v2));
        }
        return calculateDefault(conf, v1, v2);
    }
  }","@Test(timeout = 4000)
  public void test2()  throws Throwable  {
      GenericVariable<Double> genericVariable0 = new GenericVariable<Double>(""com.github.dkellenb.formulaevaluator.term.operator.GenericOperatorTerm$1"");
      DoubleGreaterEqualOperator doubleGreaterEqualOperator0 = new DoubleGreaterEqualOperator(genericVariable0, genericVariable0);
      HashMap<String, Double> hashMap0 = new HashMap<String, Double>();
      GenericInitOnlyVariableValueProvider<Double> genericInitOnlyVariableValueProvider0 = new GenericInitOnlyVariableValueProvider<Double>(hashMap0);
      FormulaEvaluatorConfiguration formulaEvaluatorConfiguration0 = new FormulaEvaluatorConfiguration();
      FormulaEvaluatorConfiguration.DefaultNullHandling formulaEvaluatorConfiguration_DefaultNullHandling0 = FormulaEvaluatorConfiguration.DefaultNullHandling.NULL;
      formulaEvaluatorConfiguration0.setDefaultNullHandling(formulaEvaluatorConfiguration_DefaultNullHandling0);
      // Undeclared exception!
      try { 
        doubleGreaterEqualOperator0.evaluate(genericInitOnlyVariableValueProvider0, formulaEvaluatorConfiguration0);
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""com.github.dkellenb.formulaevaluator.term.operator.doubletype.DoubleGreaterEqualOperator"", e);
      }
  }",Implementation for this operator.@param conf the configuration. @param v1 Operand 1. @param v2 Operand 2. @return The result of the operation.